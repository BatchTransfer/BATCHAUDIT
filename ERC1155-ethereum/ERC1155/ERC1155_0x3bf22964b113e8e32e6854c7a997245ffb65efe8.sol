{"AddressUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {UintUtils} from \"UintUtils.sol\";\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{value: amount}(\"\");\n        require(success, \"AddressUtils: failed to send value\");\n    }\n}\n"},"Counters.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\npragma solidity ^0.8.9;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n}\n"},"CreatorSpaceFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {KomonERC1155} from \"KomonERC1155.sol\";\nimport {KomonAccessControlBaseStorage} from \"KomonAccessControlBaseStorage.sol\";\nimport {Modifiers} from \"Modifiers.sol\";\nimport {AddressUtils} from \"AddressUtils.sol\";\n\ncontract CreatorSpaceFacet is KomonERC1155, Modifiers {\n    function createSpaceToken(\n        uint256[] calldata maxSupplies,\n        uint256[] calldata prices,\n        uint8[] calldata percentages,\n        address creatorAccount\n    ) external onlyKomonWeb {\n        _createSpaceToken(maxSupplies, prices, percentages, creatorAccount);\n    }\n\n    function updateTokensPrice(\n        uint256[] calldata tokenIds,\n        uint256[] calldata prices\n    ) external onlyKomonWeb {\n        setTokensPrice(tokenIds, prices, true);\n    }\n\n    function updateTokensPercentage(\n        uint256[] calldata tokenIds,\n        uint8[] calldata percentages\n    ) external onlyKomonWeb {\n        setTokensPercentage(tokenIds, percentages, true);\n    }\n\n    function mintSpaceKey(uint256 id, uint256 amount) external payable {\n        require(amount \u003e 0, \"You have to mint at least 1 token.\");\n        uint256 tokenPrice = tokenPrice(id);\n        require(\n            (totalSupply(id) + amount) \u003c= maxSupply(id),\n            \"Max amount of token reached.\"\n        );\n        require(tokenPrice \u003e 0, \"Token price must be more than 0.\");\n\n        uint256 total = amount * tokenPrice * 1 wei;\n        require(msg.value == total, \"Amount sent is not correct.\");\n\n        uint256 creatorCut = calculateCreatorCut(id, total);\n        uint256 komonCut = total - creatorCut;\n\n        address komonExchangeAccount = KomonAccessControlBaseStorage\n            .layout()\n            ._komonExchangeAccount;\n        address creatorAccount = creatorTokenOwner(id);\n\n        AddressUtils.sendValue(payable(komonExchangeAccount), komonCut);\n        AddressUtils.sendValue(payable(creatorAccount), creatorCut);\n\n        _safeMint(msg.sender, id, amount, \"\");\n    }\n\n    function mintInternalKey(uint256 amount) external onlyKomonWeb {\n        require(amount \u003e 0, \"You have to mint at least 1 token.\");\n        _mintInternalKey(amount);\n    }\n}\n"},"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"},"ERC1155Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC1155} from \"IERC1155.sol\";\nimport {IERC1155Receiver} from \"IERC1155Receiver.sol\";\nimport {IERC1155Base} from \"IERC1155Base.sol\";\nimport {ERC1155BaseInternal, ERC1155BaseStorage} from \"ERC1155BaseInternal.sol\";\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155Base, ERC1155BaseInternal {\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return _balanceOf(account, id);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            \"ERC1155: accounts and ids length mismatch\"\n        );\n\n        mapping(uint256 =\u003e mapping(address =\u003e uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i \u003c accounts.length; i++) {\n                require(\n                    accounts[i] != address(0),\n                    \"ERC1155: batch balance query for the zero address\"\n                );\n                batchBalances[i] = balances[ids[i]][accounts[i]];\n            }\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function setApprovalForAll(address operator, bool status) public virtual {\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n        ERC1155BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @notice sets the initial price for the token id\n     * @param tokenIds token id\n     * @param prices initial gwei price for the token\n     */\n    function setTokensPrice(\n        uint256[] memory tokenIds,\n        uint256[] memory prices,\n        bool isUpdate\n    ) internal {\n        uint256 length = tokenIds.length;\n        require(length == prices.length, \"TokenIds and Prices mismatch\");\n        for (uint256 i = 0; i \u003c length; ) {\n            uint256 oldPrice = ERC1155BaseStorage\n                .layout()\n                .tokenInfo[tokenIds[i]]\n                .tokenPrice;\n            require(prices[i] \u003e 0, \"Price can\u0027t be less than 0\");\n            ERC1155BaseStorage\n                .layout()\n                .tokenInfo[tokenIds[i]]\n                .tokenPrice = prices[i];\n            if (isUpdate) {\n                emit UpdatedTokenPrice(tokenIds[i], oldPrice, prices[i]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice gets the price for a token\n     * @param tokenId token id\n     * @return uint256 as token price in wei\n     */\n    function tokenPrice(uint256 tokenId) public view virtual returns (uint256) {\n        return ERC1155BaseStorage.layout().tokenInfo[tokenId].tokenPrice;\n    }\n\n    /**\n     * @notice gets the creator address owner of a token\n     * @param tokenId token id\n     * @return address as creator address owner\n     */\n    function creatorTokenOwner(uint256 tokenId)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        return ERC1155BaseStorage.layout().tokenInfo[tokenId].creatorAccount;\n    }\n\n    /**\n     * @notice gets the creator\u0027s token ids\n     * @param creatorAddress token id\n     * @return uint256 array with token ids\n     */\n    function creatorTokens(address creatorAddress)\n        public\n        view\n        virtual\n        returns (uint256[] memory)\n    {\n        return ERC1155BaseStorage.layout().creatorTokens[creatorAddress];\n    }\n\n    /**\n     * @notice sets the creator address owner of a token\n     * @param tokenId token id\n     * @param creatorAccount address account of the creator owner\n     */\n    function setCreatorTokenOwner(uint256 tokenId, address creatorAccount)\n        internal\n        virtual\n    {\n        ERC1155BaseStorage\n            .layout()\n            .tokenInfo[tokenId]\n            .creatorAccount = creatorAccount;\n        ERC1155BaseStorage.layout().creatorTokens[creatorAccount].push(tokenId);\n    }\n\n    /**\n     * @notice gets the percentage assign to a token id\n     * @param tokenId token id\n     * @return uint8 percentage for token id\n     */\n    function tokenPercentage(uint256 tokenId)\n        public\n        view\n        virtual\n        returns (uint8)\n    {\n        return ERC1155BaseStorage.layout().tokenInfo[tokenId].percentage;\n    }\n\n    /**\n     * @notice sets the token percentages\n     * @param tokenIds token id\n     * @param percentages percentage to calculate the cut for that token id\n     */\n    function setTokensPercentage(\n        uint256[] memory tokenIds,\n        uint8[] memory percentages,\n        bool isUpdate\n    ) internal virtual {\n        uint256 length = tokenIds.length;\n        require(\n            length == percentages.length,\n            \"Token ids and percentages lenght mismatch\"\n        );\n        for (uint256 i = 0; i \u003c length; ) {\n            uint8 oldPercentage = ERC1155BaseStorage\n                .layout()\n                .tokenInfo[tokenIds[i]]\n                .percentage;\n            require(\n                percentages[i] \u003e= 0 \u0026\u0026 percentages[i] \u003c= 100,\n                \"Percentage must be between 0 and 100\"\n            );\n            ERC1155BaseStorage\n                .layout()\n                .tokenInfo[tokenIds[i]]\n                .percentage = percentages[i];\n\n            if (isUpdate) {\n                emit UpdatedTokenPercentage(\n                    tokenIds[i],\n                    oldPercentage,\n                    percentages[i]\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function calculateCreatorCut(uint256 tokenId, uint256 total)\n        internal\n        virtual\n        returns (uint256)\n    {\n        uint8 percentage = tokenPercentage(tokenId);\n        return (total * percentage) / 100;\n    }\n\n    /**\n     * @notice gets the max mintable supply for a token\n     * @param tokenId token id\n     * @return uint256 as a token id\n     */\n    function maxSupply(uint256 tokenId) public view virtual returns (uint256) {\n        return ERC1155BaseStorage.layout().tokenInfo[tokenId].maxSupply;\n    }\n\n    /**\n     * @notice sets the max supply for a token\n     * @param tokenId token id\n     * @param maxTokenSupply max supply for the token id\n     */\n    function setTokenMaxSupply(uint256 tokenId, uint256 maxTokenSupply)\n        internal\n    {\n        require(maxTokenSupply \u003e 0, \"Max supply must be more than 0.\");\n        ERC1155BaseStorage\n            .layout()\n            .tokenInfo[tokenId]\n            .maxSupply = maxTokenSupply;\n    }\n}\n"},"ERC1155BaseInternal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { AddressUtils } from \"AddressUtils.sol\";\nimport { IERC1155Internal } from \"IERC1155Internal.sol\";\nimport { IERC1155Receiver } from \"IERC1155Receiver.sol\";\nimport { ERC1155BaseStorage } from \"ERC1155BaseStorage.sol\";\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155Internal {\n    using AddressUtils for address;\n\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function _balanceOf(address account, uint256 id) internal view virtual returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return ERC1155BaseStorage.layout().balances[id][account];\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        _beforeTokenTransfer(msg.sender, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        ERC1155BaseStorage.layout().balances[id][account] += amount;\n\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _safeMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _mint(account, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _transfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(recipient != address(0), \"ERC1155: transfer to the zero address\");\n\n        _beforeTokenTransfer(operator, sender, recipient, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        mapping(uint256 =\u003e mapping(address =\u003e uint256)) storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            uint256 senderBalance = balances[id][sender];\n            require(senderBalance \u003e= amount, \"ERC1155: insufficient balances for transfer\");\n            balances[id][sender] = senderBalance - amount;\n        }\n\n        balances[id][recipient] += amount;\n\n        emit TransferSingle(operator, sender, recipient, id, amount);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _transfer(operator, sender, recipient, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(operator, sender, recipient, id, amount, data);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _transferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(recipient != address(0), \"ERC1155: transfer to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n        mapping(uint256 =\u003e mapping(address =\u003e uint256)) storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i \u003c ids.length; ) {\n            uint256 token = ids[i];\n            uint256 amount = amounts[i];\n\n            unchecked {\n                uint256 senderBalance = balances[token][sender];\n\n                require(senderBalance \u003e= amount, \"ERC1155: insufficient balances for transfer\");\n\n                balances[token][sender] = senderBalance - amount;\n\n                i++;\n            }\n\n            // balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\n            balances[token][recipient] += amount;\n        }\n\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, sender, recipient, ids, amounts, data);\n    }\n\n    /**\n     * @notice wrap given element in array of length 1\n     * @param element element to wrap\n     * @return singleton array\n     */\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                require(\n                    response == IERC1155Receiver.onERC1155Received.selector,\n                    \"ERC1155: ERC1155Receiver rejected tokens\"\n                );\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                require(\n                    response == IERC1155Receiver.onERC1155BatchReceived.selector,\n                    \"ERC1155: ERC1155Receiver rejected tokens\"\n                );\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    /**\n     * @notice ERC1155 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @dev called for both single and batch transfers\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n}\n"},"ERC1155BaseStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary ERC1155BaseStorage {\n    struct Layout {\n        mapping(uint256 =\u003e mapping(address =\u003e uint256)) balances;\n        mapping(address =\u003e mapping(address =\u003e bool)) operatorApprovals;\n        mapping(uint256 =\u003e TokenData) tokenInfo;\n        mapping(address =\u003e uint256[]) creatorTokens;\n    }\n\n    struct TokenData {\n        uint256 tokenPrice;\n        uint256 maxSupply;\n        uint8 percentage;\n        address creatorAccount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"komon.contracts.storage.ERC1155Base\");\n\n    function layout() internal pure returns (Layout storage lay) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            lay.slot := slot\n        }\n    }\n}\n"},"ERC1155Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {EnumerableSet} from \"EnumerableSet.sol\";\nimport {ERC1155BaseInternal} from \"ERC1155BaseInternal.sol\";\nimport {IERC1155Enumerable} from \"IERC1155Enumerable.sol\";\nimport {Counters} from \"Counters.sol\";\nimport {ERC1155EnumerableInternal, ERC1155EnumerableStorage} from \"ERC1155EnumerableInternal.sol\";\n\n/**\n * @title ERC1155 implementation including enumerable and aggregate functions\n */\nabstract contract ERC1155Enumerable is\n    IERC1155Enumerable,\n    ERC1155EnumerableInternal\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using Counters for Counters.Counter;\n\n    Counters.Counter public _tokenIds;\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalHolders(uint256 id) public view virtual returns (uint256) {\n        return _totalHolders(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function accountsByToken(uint256 id)\n        public\n        view\n        virtual\n        returns (address[] memory)\n    {\n        return _accountsByToken(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function tokensByAccount(address account)\n        public\n        view\n        virtual\n        returns (uint256[] memory)\n    {\n        return _tokensByAccount(account);\n    }\n\n    /**\n     * @notice generate a new token id everytime is called\n     * @return uint256 as a token id\n     */\n    function getNewTokenId() internal returns (uint256) {\n        _tokenIds.increment();\n        uint256 newTokenId = _tokenIds.current();\n        return newTokenId;\n    }\n}\n"},"ERC1155EnumerableInternal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {EnumerableSet} from \"EnumerableSet.sol\";\nimport {ERC1155BaseInternal, ERC1155BaseStorage} from \"ERC1155BaseInternal.sol\";\nimport {ERC1155EnumerableStorage} from \"ERC1155EnumerableStorage.sol\";\n\n/**\n * @title ERC1155Enumerable internal functions\n */\nabstract contract ERC1155EnumerableInternal is ERC1155BaseInternal {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function _totalSupply(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().totalSupply[id];\n    }\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function _totalHolders(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().accountsByToken[id].length();\n    }\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function _accountsByToken(uint256 id)\n        internal\n        view\n        virtual\n        returns (address[] memory)\n    {\n        EnumerableSet.AddressSet storage accounts = ERC1155EnumerableStorage\n            .layout()\n            .accountsByToken[id];\n\n        address[] memory addresses = new address[](accounts.length());\n\n        unchecked {\n            for (uint256 i; i \u003c accounts.length(); i++) {\n                addresses[i] = accounts.at(i);\n            }\n        }\n\n        return addresses;\n    }\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function _tokensByAccount(address account)\n        internal\n        view\n        virtual\n        returns (uint256[] memory)\n    {\n        EnumerableSet.UintSet storage tokens = ERC1155EnumerableStorage\n            .layout()\n            .tokensByAccount[account];\n\n        uint256[] memory ids = new uint256[](tokens.length());\n\n        unchecked {\n            for (uint256 i; i \u003c tokens.length(); i++) {\n                ids[i] = tokens.at(i);\n            }\n        }\n\n        return ids;\n    }\n\n    /**\n     * @notice ERC1155 hook: update aggregate values\n     * @inheritdoc ERC1155BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from != to) {\n            ERC1155EnumerableStorage.Layout\n                storage lay = ERC1155EnumerableStorage.layout();\n            mapping(uint256 =\u003e EnumerableSet.AddressSet)\n                storage tokenAccounts = lay.accountsByToken;\n            EnumerableSet.UintSet storage fromTokens = lay.tokensByAccount[\n                from\n            ];\n            EnumerableSet.UintSet storage toTokens = lay.tokensByAccount[to];\n\n            for (uint256 i; i \u003c ids.length; ) {\n                uint256 amount = amounts[i];\n\n                if (amount \u003e 0) {\n                    uint256 id = ids[i];\n\n                    if (from == address(0)) {\n                        lay.totalSupply[id] += amount;\n                    } else if (_balanceOf(from, id) == amount) {\n                        tokenAccounts[id].remove(from);\n                        fromTokens.remove(id);\n                    }\n\n                    if (to == address(0)) {\n                        lay.totalSupply[id] -= amount;\n                    } else if (_balanceOf(to, id) == 0) {\n                        tokenAccounts[id].add(to);\n                        toTokens.add(id);\n                    }\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n}\n"},"ERC1155EnumerableStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {EnumerableSet} from \"EnumerableSet.sol\";\n\nlibrary ERC1155EnumerableStorage {\n    struct Layout {\n        mapping(uint256 =\u003e uint256) totalSupply;\n        mapping(uint256 =\u003e EnumerableSet.AddressSet) accountsByToken;\n        mapping(address =\u003e EnumerableSet.UintSet) tokensByAccount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"komon.contracts.storage.ERC1155Enumerable\");\n\n    function layout() internal pure returns (Layout storage lay) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            lay.slot := slot\n        }\n    }\n}\n"},"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC165} from \"IERC165.sol\";\nimport {LibDiamond} from \"LibDiamond.sol\";\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"},"IDiamondCut.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"},"IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC1155Internal} from \"IERC1155Internal.sol\";\nimport {IERC165} from \"IERC165.sol\";\n\n/**\n * @title ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(address account, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"},"IERC1155Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC1155} from \"IERC1155.sol\";\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155Base is IERC1155 {\n    event UpdatedTokenPrice(\n        uint256 tokenId,\n        uint256 oldPrice,\n        uint256 newPrice\n    );\n\n    event UpdatedTokenPercentage(\n        uint256 tokenId,\n        uint8 oldPercentage,\n        uint8 percentage\n    );\n}\n"},"IERC1155Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC1155Internal} from \"IERC1155Internal.sol\";\n\n/**\n * @title ERC1155 enumerable and aggregate function interface\n */\ninterface IERC1155Enumerable is IERC1155Internal {\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function totalHolders(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function accountsByToken(uint256 id)\n        external\n        view\n        returns (address[] memory);\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function tokensByAccount(address account)\n        external\n        view\n        returns (uint256[] memory);\n}\n"},"IERC1155Internal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC165} from \"IERC165.sol\";\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"},"IERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC165} from \"IERC165.sol\";\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function\u0027s own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function\u0027s own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IKomonERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC1155Base} from \"IERC1155Base.sol\";\nimport {IERC1155Enumerable} from \"IERC1155Enumerable.sol\";\n\ninterface IKomonERC1155 is IERC1155Base, IERC1155Enumerable {\n    event CreatedSpaceToken(\n        uint256 newTokenId,\n        uint256 maxSupply,\n        uint256 initialPrice,\n        uint8 percentage,\n        address creatorAccount\n    );\n\n    event InternalKomonKeysMinted(\n        address sender,\n        uint256 newTokenId,\n        uint256 amount\n    );\n}\n"},"KomonAccessControlBaseStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary KomonAccessControlBaseStorage {\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 public constant KOMON_WEB_ROLE = keccak256(\"KOMON_WEB_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    struct Layout {\n        mapping(bytes32 =\u003e RoleData) _roles;\n        mapping(uint256 =\u003e address) creatorTokens;\n        address _komonExchangeAccount;\n    }\n\n    struct RoleData {\n        mapping(address =\u003e bool) members;\n        bytes32 adminRole;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"komon.contracts.access.storage.KomonAccessControlBase\");\n\n    function layout() internal pure returns (Layout storage lay) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            lay.slot := slot\n        }\n    }\n\n    function grantAdminRole(address account) internal {\n        KomonAccessControlBaseStorage.layout()._roles[DEFAULT_ADMIN_ROLE].members[account] = true;\n    }\n\n    function grantWebRole(address account) internal {\n        KomonAccessControlBaseStorage.layout()._roles[KOMON_WEB_ROLE].members[account] = true;\n    }\n\n    function grantCreatorRole(address account) internal {\n        KomonAccessControlBaseStorage.layout()._roles[CREATOR_ROLE].members[account] = true;\n    }\n\n    function setKomonExchangeAccount(address account) internal {\n        KomonAccessControlBaseStorage.layout()._komonExchangeAccount = account;\n    }\n\n    function hasAdminRole(address account) internal view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function hasKomonWebRole(address account) internal view returns (bool) {\n        return hasRole(KOMON_WEB_ROLE, account);\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return KomonAccessControlBaseStorage.layout()._roles[role].members[account];\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        KomonAccessControlBaseStorage.layout()._roles[role].adminRole = adminRole;\n    }\n}\n"},"KomonERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ERC1155Base, ERC1155BaseInternal} from \"ERC1155Base.sol\";\nimport {ERC1155Enumerable} from \"ERC1155Enumerable.sol\";\nimport {ERC1155EnumerableInternal} from \"ERC1155EnumerableInternal.sol\";\nimport {IKomonERC1155} from \"IKomonERC1155.sol\";\nimport {ERC165} from \"ERC165.sol\";\nimport {KomonAccessControlBaseStorage} from \"KomonAccessControlBaseStorage.sol\";\n\n/**\n * @title Komon ERC1155 implementation\n */\nabstract contract KomonERC1155 is\n    IKomonERC1155,\n    ERC1155Base,\n    ERC1155Enumerable,\n    ERC165\n{\n    /**\n     * @inheritdoc ERC1155BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override(ERC1155BaseInternal, ERC1155EnumerableInternal)\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function _createSpaceToken(\n        uint256[] calldata maxSupplies,\n        uint256[] calldata prices,\n        uint8[] calldata percentages,\n        address creatorAccount\n    ) internal {\n        uint256 length = maxSupplies.length;\n        require(\n            length == prices.length \u0026\u0026 prices.length == percentages.length,\n            \"MaxSupplies, prices and percentage length mismatch\"\n        );\n        uint256[] memory tokenIds = new uint256[](length);\n        uint256[] memory pricesArray = new uint256[](length);\n        uint8[] memory percentageArray = new uint8[](length);\n\n        for (uint256 i = 0; i \u003c length; ) {\n            uint256 newTokenId = getNewTokenId();\n            setTokenMaxSupply(newTokenId, maxSupplies[i]);\n            _setCreatorTokenOwner(newTokenId, creatorAccount);\n\n            tokenIds[i] = newTokenId;\n            pricesArray[i] = prices[i];\n            percentageArray[i] = percentages[i];\n\n            emit CreatedSpaceToken(\n                newTokenId,\n                maxSupplies[i],\n                prices[i],\n                percentages[i],\n                creatorAccount\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        setTokensPrice(tokenIds, pricesArray, false);\n        setTokensPercentage(tokenIds, percentageArray, false);\n    }\n\n    function _setCreatorTokenOwner(uint256 newTokenId, address creatorAccount)\n        private\n    {\n        setCreatorTokenOwner(newTokenId, creatorAccount);\n        KomonAccessControlBaseStorage.grantCreatorRole(creatorAccount);\n    }\n\n    function _mintInternalKey(uint256 amount) internal {\n        uint256 newTokenId = getNewTokenId();\n        _mint(msg.sender, newTokenId, amount, \"\");\n        emit InternalKomonKeysMinted(msg.sender, newTokenId, amount);\n    }\n}\n"},"LibDiamond.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IDiamondCut} from \"IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"komon.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 =\u003e FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address =\u003e FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 =\u003e bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"LibDiamond: Must be contract owner\"\n        );\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex \u003c _diamondCut.length; ) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n            unchecked {\n                facetIndex++;\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length \u003e 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Add facet can\u0027t be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex \u003c _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress == address(0),\n                \"LibDiamondCut: Can\u0027t add function that already exists\"\n            );\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n            unchecked {\n                selectorIndex++;\n            }\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length \u003e 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Add facet can\u0027t be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex \u003c _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress != _facetAddress,\n                \"LibDiamondCut: Can\u0027t replace function with same function\"\n            );\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n            unchecked {\n                selectorIndex++;\n            }\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length \u003e 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(\n            _facetAddress == address(0),\n            \"LibDiamondCut: Remove facet address must be address(0)\"\n        );\n        for (\n            uint256 selectorIndex;\n            selectorIndex \u003c _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n            unchecked {\n                selectorIndex++;\n            }\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress)\n        internal\n    {\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDiamondCut: New facet has no code\"\n        );\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\n            .facetAddresses\n            .length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n            _selector\n        );\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondStorage storage ds,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Can\u0027t remove function that doesn\u0027t exist\"\n        );\n        // an immutable function is a function defined directly in a diamond\n        require(\n            _facetAddress != address(this),\n            \"LibDiamondCut: Can\u0027t remove immutable function\"\n        );\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                    selectorPosition\n                ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) {\n            require(\n                _calldata.length == 0,\n                \"LibDiamondCut: _init is address(0) but_calldata is not empty\"\n            );\n        } else {\n            require(\n                _calldata.length \u003e 0,\n                \"LibDiamondCut: _calldata is empty but _init is not address(0)\"\n            );\n            if (_init != address(this)) {\n                enforceHasContractCode(\n                    _init,\n                    \"LibDiamondCut: _init address has no code\"\n                );\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length \u003e 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize \u003e 0, _errorMessage);\n    }\n}\n"},"Modifiers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {KomonAccessControlBaseStorage} from \"KomonAccessControlBaseStorage.sol\";\n\ncontract Modifiers {\n    modifier onlyKomonWeb() {\n        require(\n            KomonAccessControlBaseStorage.hasKomonWebRole(msg.sender) ||\n                KomonAccessControlBaseStorage.hasAdminRole(msg.sender),\n            \"Restricted to komon web role.\"\n        );\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(\n            KomonAccessControlBaseStorage.hasAdminRole(msg.sender),\n            \"Restricted to admin role.\"\n        );\n        _;\n    }\n}\n"},"UintUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    bytes16 private constant HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp \u003e\u003e= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value \u0026 0xf];\n                value \u003e\u003e= 4;\n            }\n        }\n\n        require(value == 0, \"UintUtils: hex length insufficient\");\n\n        return string(buffer);\n    }\n}\n"}}