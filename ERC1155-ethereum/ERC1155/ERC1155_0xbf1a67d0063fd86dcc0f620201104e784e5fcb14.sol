{"ERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8;\n\ninterface iERC1155 {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external returns (bytes4);\n}\n\n// author: jolan.eth\nabstract contract ERC1155 {\n    mapping(uint256 =\u003e uint256) supply;\n    mapping(uint256 =\u003e mapping(address =\u003e uint256)) balances;\n    mapping(address =\u003e mapping(address =\u003e bool)) operatorApprovals;\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == 0xd9b67a26 || interfaceId == 0x0e89341c;\n    }\n\n    function totalSupply(uint256 id) public view returns (uint256) {\n        return supply[id];\n    }\n\n    function balanceOf(address owner, uint256 id)\n        public\n        view\n        returns (uint256)\n    {\n        require(\n            owner != address(0),\n            \"ERC1155::balanceOf() - owner is address(0)\"\n        );\n        return balances[id][owner];\n    }\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        require(\n            owners.length == ids.length,\n            \"ERC1155::balanceOfBatch() - owners length don\u0027t match ids length\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](owners.length);\n\n        uint256 i = 0;\n        while (i \u003c owners.length)\n            batchBalances[i] = balanceOf(owners[i], ids[i++]);\n\n        return batchBalances;\n    }\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return operatorApprovals[owner][operator];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155::safeTransferFrom() - msg.sender is not owner or approved\"\n        );\n\n        uint256 fromBalance = balances[id][from];\n        require(\n            fromBalance \u003e= amount,\n            \"ERC1155::safeTransferFrom() - fromBalance is lower than amount\"\n        );\n\n        unchecked {\n            balances[id][from] = fromBalance - amount;\n        }\n\n        balances[id][to] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155::safeBatchTransferFrom() - msg.sender is not owner or approved\"\n        );\n\n        require(\n            ids.length == amounts.length,\n            \"ERC1155::safeBatchTransferFrom() - ids.length don\u0027t match amounts.length\"\n        );\n\n        require(\n            to != address(0),\n            \"ERC1155::safeBatchTransferFrom() - to is address(0)\"\n        );\n\n        address operator = msg.sender;\n\n        uint256 i = 0;\n        while (i \u003c ids.length) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = balances[id][from];\n            require(\n                fromBalance \u003e= amount,\n                \"ERC1155::safeBatchTransferFrom() - balance is lower than amount\"\n            );\n            unchecked {\n                balances[id][from] = fromBalance - amount;\n            }\n            balances[id][to] += amount;\n            ++i;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    function safeBatchTransferFromInternal(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155::safeBatchTransferFrom() - ids.length don\u0027t match amounts.length\"\n        );\n\n        require(\n            to != address(0),\n            \"ERC1155::safeBatchTransferFrom() - to is address(0)\"\n        );\n\n        address operator = address(this);\n\n        uint256 i = 0;\n        while (i \u003c ids.length) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = balances[id][from];\n            require(\n                fromBalance \u003e= amount,\n                \"ERC1155::safeBatchTransferFrom() - balance is lower than amount\"\n            );\n            unchecked {\n                balances[id][from] = fromBalance - amount;\n            }\n            balances[id][to] += amount;\n            ++i;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) private {\n        require(owner != operator, \"error owner\");\n        operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"ERC1155::_mint() - to is address(0)\");\n\n        supply[id]++;\n        balances[id][to] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            to,\n            id,\n            amount,\n            data\n        );\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        uint256 size;\n        assembly {\n            size := extcodesize(to)\n        }\n        if (size \u003e 0) {\n            try\n                iERC1155(to).onERC1155Received(operator, from, id, amount, data)\n            returns (bytes4 response) {\n                if (response != iERC1155.onERC1155Received.selector) {\n                    revert(\n                        \"ERC1155::doSafeTransferAcceptanceCheck() - error receiver\"\n                    );\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\n                    \"ERC1155::doSafeTransferAcceptanceCheck() - error receiver\"\n                );\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        uint256 size;\n        assembly {\n            size := extcodesize(to)\n        }\n        if (size \u003e 0) {\n            try\n                iERC1155(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (response != iERC1155.onERC1155BatchReceived.selector) {\n                    revert(\n                        \"ERC1155::doSafeTransferAcceptanceCheck() - error receiver\"\n                    );\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\n                    \"ERC1155::doSafeTransferAcceptanceCheck() - error receiver\"\n                );\n            }\n        }\n    }\n}\n"},"Registry.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8;\n\n// author: jolan.eth\nabstract contract Registry {\n    struct RCSA {\n        address NFTContract;\n        uint256 id;\n    }\n\n    mapping(uint256 =\u003e RCSA) REKTRegistry;\n    \n    function getREKTRegistry(uint256 id)\n    public view returns (RCSA memory) {\n        RCSA storage Object = REKTRegistry[id];\n        return Object;\n    }\n\n    function setRCSARegistration(uint256 tokenId, address NFTContract, uint256 id)\n    internal {\n        REKTRegistry[tokenId] = RCSA(\n            NFTContract, id\n        );\n    }\n}"},"REKT.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8;\n\nimport \"./ERC1155.sol\";\nimport \"./Registry.sol\";\n\ninterface iREKT {\n    function exist(uint256) external view returns (bool);\n\n    function uri(uint256) external view returns (string memory);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function supportsInterface(bytes4) external view returns (bool);\n}\n\n/// RRRRRRRRRRRRRRRRR   EEEEEEEEEEEEEEEEEEEEEEKKKKKKKKK    KKKKKKKTTTTTTTTTTTTTTTTTTTTTTT\n/// R::::::::::::::::R  E::::::::::::::::::::EK:::::::K    K:::::KT:::::::::::::::::::::T\n/// R::::::RRRRRR:::::R E::::::::::::::::::::EK:::::::K    K:::::KT:::::::::::::::::::::T\n/// RR:::::R     R:::::REE::::::EEEEEEEEE::::EK:::::::K   K::::::KT:::::TT:::::::TT:::::T\n///   R::::R     R:::::R  E:::::E       EEEEEEKK::::::K  K:::::KKKTTTTTT  T:::::T  TTTTTT\n///   R::::R     R:::::R  E:::::E               K:::::K K:::::K           T:::::T        \n///   R::::RRRRRR:::::R   E::::::EEEEEEEEEE     K::::::K:::::K            T:::::T        \n///   R:::::::::::::RR    E:::::::::::::::E     K:::::::::::K             T:::::T        \n///   R::::RRRRRR:::::R   E:::::::::::::::E     K:::::::::::K             T:::::T        \n///   R::::R     R:::::R  E::::::EEEEEEEEEE     K::::::K:::::K            T:::::T        \n///   R::::R     R:::::R  E:::::E               K:::::K K:::::K           T:::::T        \n///   R::::R     R:::::R  E:::::E       EEEEEEKK::::::K  K:::::KKK        T:::::T        \n/// RR:::::R     R:::::REE::::::EEEEEEEE:::::EK:::::::K   K::::::K      TT:::::::TT      \n/// R::::::R     R:::::RE::::::::::::::::::::EK:::::::K    K:::::K      T:::::::::T      \n/// R::::::R     R:::::RE::::::::::::::::::::EK:::::::K    K:::::K      T:::::::::T      \n/// RRRRRRRR     RRRRRRREEEEEEEEEEEEEEEEEEEEEEKKKKKKKKK    KKKKKKK      TTTTTTTTTTT      \n                                                                                     \n// author: jolan.eth\ncontract REKT is ERC1155, Registry {\n    constructor() {}\n\n    function name() public pure returns (string memory) {\n        return \"REKT\";\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"RCSA\";\n    }\n\n    function mintRCSA(\n        address source,\n        uint256 id,\n        uint256 amount\n    ) public {\n        require(\n            source != address(0),\n            \"REKT::mintRCSA() - source does not exist\"\n        );\n\n        require(amount \u003e 0, \"REKT::mintRCSA() - amount is 0\");\n\n        uint256 tokenId = uint256(\n            keccak256(abi.encodePacked(uint256(uint160(address(source))), id))\n        );\n\n        if (ERC1155.totalSupply(tokenId) == 0) {\n            Registry.setRCSARegistration(tokenId, address(source), id);\n        }\n\n        ERC1155._mint(msg.sender, tokenId, amount, \"\");\n    }\n\n    function uri(uint256 id) public view returns (string memory) {\n        require(ERC1155.totalSupply(id) \u003e 0, \"REKT::uri() - id does not exist\");\n        Registry.RCSA memory Entry = Registry.getREKTRegistry(id);\n        iREKT Reader = iREKT(Entry.NFTContract);\n        if (Reader.supportsInterface(0x80ac58cd))\n            return Reader.tokenURI(Entry.id);\n        if (Reader.supportsInterface(0xd9b67a26)) return Reader.uri(Entry.id);\n        return \"REKT\";\n    }\n\n    function owner() public pure returns (address) {\n        return address(0);\n    }\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes\n            memory table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\n                )\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"}}