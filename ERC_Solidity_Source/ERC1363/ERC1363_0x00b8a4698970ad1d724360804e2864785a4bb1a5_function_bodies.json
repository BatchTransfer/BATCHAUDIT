{
    "mint(address,uint256)": "function mint(address to, uint256 amount) external {\n        address sender = _msgSender();\n\n        // only admin\n        if (!hasRole(DEFAULT_ADMIN_ROLE, sender)) {\n            revert ErrForbidden();\n        }\n\n        _mint(to, amount);\n    }",
    "recoverERC20(address,address,uint256)": "function recoverERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        // only admin\n        if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) {\n            revert ErrForbidden();\n        }\n\n        _recoverERC20(token, to, amount);\n    }",
    "_mint(address,uint256)": "function _mint(address to, uint256 amount)\n        internal\n        override(ERC20, ERC20Capped)\n    {\n        ERC20Capped._mint(to, amount);\n    }",
    "burn(uint256)": "function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }",
    "burnFrom(address,uint256)": "function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }",
    "cap()": "function cap() public view virtual returns (uint256) {\n        return _cap;\n    }",
    "transferAdmin(address)": "function transferAdmin(address newAdmin)\n        external\n        virtual\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (newAdmin == address(0)) {\n            revert ErrGrantRoleToZeroAddress();\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        _revokeRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }",
    "_recoverERC20(address,address,uint256)": "function _recoverERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        emit RecoverERC20(token, to, amount);\n        IERC20(token).safeTransfer(to, amount);\n    }",
    "name()": "function name() public view virtual override returns (string memory) {\n        return _name;\n    }",
    "symbol()": "function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }",
    "decimals()": "function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }",
    "increaseAllowance(address,uint256)": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }",
    "decreaseAllowance(address,uint256)": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }",
    "_transfer(address,address,uint256)": "function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }",
    "_burn(address,uint256)": "function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }",
    "_approve(address,address,uint256)": "function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }",
    "_spendAllowance(address,address,uint256)": "function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }",
    "_beforeTokenTransfer(address,address,uint256)": "function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}",
    "_afterTokenTransfer(address,address,uint256)": "function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}",
    "_msgSender()": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
    "_msgData()": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
    "isContract(address)": "function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }",
    "hasRole(bytes32,address)": "function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }",
    "_checkRole(bytes32)": "function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }",
    "_checkRole(bytes32,address)": "function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }",
    "getRoleAdmin(bytes32)": "function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }",
    "grantRole(bytes32,address)": "function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }",
    "revokeRole(bytes32,address)": "function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }",
    "renounceRole(bytes32,address)": "function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }",
    "_setupRole(bytes32,address)": "function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }",
    "_setRoleAdmin(bytes32,bytes32)": "function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }",
    "_grantRole(bytes32,address)": "function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }",
    "_revokeRole(bytes32,address)": "function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }",
    "toString(uint256)": "function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }",
    "toHexString(uint256)": "function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }",
    "toHexString(uint256,uint256)": "function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }",
    "safeTransfer(IERC20,address,uint256)": "function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }",
    "safeTransferFrom(IERC20,address,address,uint256)": "function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }",
    "safeApprove(IERC20,address,uint256)": "function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }",
    "safeIncreaseAllowance(IERC20,address,uint256)": "function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }",
    "safeDecreaseAllowance(IERC20,address,uint256)": "function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }"
}