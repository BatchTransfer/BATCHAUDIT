{"Factory1155.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport \"./MarleyDigitalMediaUserToken1155.sol\";\n\ncontract Factory1155 {\n\tevent Deployed(address owner, address contractAddress);\n\n\tfunction deploy(bytes32 _salt, string memory name, string memory symbol, string memory tokenURIPrefix) external returns(address addr) {\n\t\taddr = address(new MarleyDigitalMediaUserToken1155{salt: _salt}(name, symbol, tokenURIPrefix));\n\t\tMarleyDigitalMediaUserToken1155 token = MarleyDigitalMediaUserToken1155(address(addr));\n\t\ttoken.transferOwnership(msg.sender);\n\t\temit Deployed(msg.sender, addr);\n\t}\n}\n"},"MarleyDigitalMediaUserToken1155.sol":{"content":"// SPDX-License-Identifier:UNLICENSED\npragma solidity 0.8.13;\n\nlibrary Strings {\n\n    function toString(uint256 value) internal pure returns (string memory) {\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n\nlibrary EnumerableMap {\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n\n        mapping (bytes32 =\u003e uint256) _indexes;\n    }\n\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            map._entries[toDeleteIndex] = lastEntry;\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            map._entries.pop();\n\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length \u003e index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        mapping (bytes32 =\u003e uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n            bytes32 lastvalue = set._values[lastIndex];\n\n            set._values[toDeleteIndex] = lastvalue;\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            set._values.pop();\n\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\ninterface IERC165 {\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC1155 is IERC165 {\n\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    event tokenBaseURI(string value);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function royaltyFee(uint256 tokenId) external view returns(uint256);\n    function getCreator(uint256 tokenId) external view returns(address);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n    function setApprovalForAll(address operator, bool approved) external;\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n\ninterface IERC1155MetadataURI is IERC1155 {\n}\n\ninterface IERC1155Receiver is IERC165 {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    mapping(bytes4 =\u003e bool) private _supportedInterfaces;\n\n    constructor () {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    using Strings for uint256;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 =\u003e address) private creators;\n    mapping (uint256 =\u003e uint256) public _royaltyFee;\n    mapping (uint256 =\u003e mapping(address =\u003e uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n    string public tokenURIPrefix;\n\n    // Optional mapping for token URIs\n    mapping(uint256 =\u003e string) private _tokenURIs;\n\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    string private _name;\n\n    string private _symbol;\n\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _registerInterface(_INTERFACE_ID_ERC1155);\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        _tokenURIs[tokenId] = uri;\n    }\n\n    function royaltyFee(uint256 tokenId) public view override returns(uint256) {\n        return _royaltyFee[tokenId];\n    }\n\n    function getCreator(uint256 tokenId) public view virtual override returns(address) {\n        return creators[tokenId];\n    }\n\n    function _setTokenURIPrefix(string memory _tokenURIPrefix) internal {\n        tokenURIPrefix = _tokenURIPrefix;\n        emit tokenBaseURI(tokenURIPrefix);\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC1155Metadata: URI query for nonexistent token\");\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = tokenURIPrefix;\n\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length \u003e 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    function balanceOf(address account, uint256 tokenId) public view override returns (uint256) {\n        require(_exists(tokenId), \"ERC1155Metadata: balance query for nonexistent token\");\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[tokenId][account];\n    }\n\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i \u003c accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        require( _balances[tokenId][from] \u003e= amount,\"ERC1155: insufficient balance for transfer\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(tokenId), _asSingletonArray(amount), data);\n        \n        _balances[tokenId][from] = _balances[tokenId][from] - amount;\n        _balances[tokenId][to] = _balances[tokenId][to] + amount;\n\n        emit TransferSingle(operator, from, to, tokenId, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, tokenId, amount, data);\n    }\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size \u003e 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param tokenIds     IDs of each token type (order and length must match _values array)\n        @param amounts  Transfer amounts per token type (order and length must match _ids array)\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, tokenIds, amounts, data);\n\n        for (uint256 i = 0; i \u003c tokenIds.length; ++i) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = amounts[i];\n            require( _balances[tokenId][from] \u003e= amount,\"ERC1155: insufficient balance for transfer\");\n            _balances[tokenId][from] = _balances[tokenId][from] - amount;\n            _balances[tokenId][to] = _balances[tokenId][to] + amount;\n        }\n\n        emit TransferBatch(operator, from, to, tokenIds, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, tokenIds, amounts, data);\n    }\n\n\n\n    /**\n        * @dev Internal function to mint a new token.\n        * Reverts if the given token ID already exists.\n        * @param tokenId uint256 ID of the token to be minted\n        * @param _supply uint256 supply of the token to be minted\n        * @param _uri string memory URI of the token to be minted\n        * @param _fee uint256 royalty of the token to be minted\n    */\n\n    function _mint(uint256 tokenId, uint256 _supply, string memory _uri, uint256 _fee) internal {\n        require(!_exists(tokenId), \"ERC1155: token already minted\");\n        require(_supply != 0, \"Supply should be positive\");\n        require(bytes(_uri).length \u003e 0, \"uri should be set\");\n\n        creators[tokenId] = msg.sender;\n        _tokenOwners.set(tokenId, msg.sender);\n        _royaltyFee[tokenId] = _fee;\n        _balances[tokenId][msg.sender] = _supply;\n        _setTokenURI(tokenId, _uri);\n\n        emit TransferSingle(msg.sender, address(0x0), msg.sender, tokenId, _supply);\n        emit URI(_uri, tokenId);\n    }\n\n    /**\n        * @dev version of {_mint}.\n        *\n        * Requirements:\n        *\n        * - `tokenIds` and `amounts` must have the same length.\n    */\n\n    function _mintBatch(address to, uint256[] memory tokenIds, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, tokenIds, amounts, data);\n\n        for (uint i = 0; i \u003c tokenIds.length; i++) {\n            _balances[tokenIds[i]][to] = amounts[i] + _balances[tokenIds[i]][to];\n        }\n\n        emit TransferBatch(operator, address(0), to, tokenIds, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, tokenIds, amounts, data);\n    }\n\n    /**\n        * @dev Internal function to burn a specific token.\n        * Reverts if the token does not exist.\n        * Deprecated, use {ERC721-_burn} instead.\n        * @param account owner of the token to burn\n        * @param tokenId uint256 ID of the token being burned\n        * @param amount uint256 amount of supply being burned\n    */    \n\n    function _burn(address account, uint256 tokenId, uint256 amount) internal virtual {\n        require(_exists(tokenId), \"ERC1155Metadata: burn query for nonexistent token\");\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require( _balances[tokenId][account] \u003e= amount,\"ERC1155: insufficient balance for transfer\");\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(tokenId), _asSingletonArray(amount), \"\");\n\n        _balances[tokenId][account] = _balances[tokenId][account] - amount;\n\n\n        emit TransferSingle(operator, account, address(0), tokenId, amount);\n    }\n\n\n    /**\n        * @dev version of {_burn}.\n        * Requirements:\n        * - `ids` and `amounts` must have the same length.\n    */\n\n    function _burnBatch(address account, uint256[] memory tokenIds, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), tokenIds, amounts, \"\");\n\n        for (uint i = 0; i \u003c tokenIds.length; i++) {\n        require( _balances[tokenIds[i]][account] \u003e= amounts[i],\"ERC1155: insufficient balance for transfer\");\n            _balances[tokenIds[i]][account] = _balances[tokenIds[i]][account] - amounts[i];\n        }\n\n        emit TransferBatch(operator, account, address(0), tokenIds, amounts);\n    }\n\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, tokenId, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, tokenIds, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\ncontract MarleyDigitalMediaUserToken1155 is ERC1155 {\n\n    uint256 newItemId = 1;\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor (string memory name, string memory symbol, string memory tokenURIPrefix) ERC1155 (name, symbol) {\n        owner = msg.sender;\n        _setTokenURIPrefix(tokenURIPrefix);\n\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner returns(bool) {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        return true;\n    }\n\n    function mint(string memory uri, uint256 supply, uint256 fee) external {\n        _mint(newItemId, supply, uri,fee);\n        newItemId = newItemId+1;\n    }\n\n    function setBaseURI(string memory _baseURI) external onlyOwner {\n        _setTokenURIPrefix(_baseURI);\n    }\n\n    function burn(uint256 tokenId, uint256 supply) external {\n        _burn(msg.sender, tokenId, supply);\n    }\n\n    function burnBatch(uint256[] memory tokenIds, uint256[] memory amounts) external {\n        _burnBatch(msg.sender, tokenIds, amounts);\n    }\n}"}}