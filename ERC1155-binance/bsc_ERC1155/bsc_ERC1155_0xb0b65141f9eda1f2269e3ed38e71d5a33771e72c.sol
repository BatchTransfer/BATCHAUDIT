{"Base.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\n    library SafeMath {//konwnsec//IERC20 接口\r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            if (a == 0) {\r\n                return 0; \r\n            }\r\n            uint256 c = a * b;\r\n            assert(c / a == b);\r\n            return c; \r\n        }\r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// assert(b \u003e 0); // Solidity automatically throws when dividing by 0\r\n            uint256 c = a / b;\r\n// assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n            return c; \r\n        }\r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            assert(b \u003c= a);\r\n            return a - b; \r\n        }\r\n\r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            uint256 c = a + b;\r\n            assert(c \u003e= a);\r\n            return c; \r\n        }\r\n    }\r\n\r\n    interface Erc20Token {//konwnsec//ERC20 接口\r\n        function totalSupply() external view returns (uint256);\r\n        function balanceOf(address _who) external view returns (uint256);\r\n        function transfer(address _to, uint256 _value) external;\r\n        function allowance(address _owner, address _spender) external view returns (uint256);\r\n        function transferFrom(address _from, address _to, uint256 _value) external;\r\n        function approve(address _spender, uint256 _value) external; \r\n        function burnFrom(address _from, uint256 _value) external; \r\n            function mint(uint256 amount) external  returns (bool);\r\n\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n        \r\n\r\n    }\r\n    \r\n \r\n interface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n \r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function mintBatch2(\r\n        address[] memory accounts,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) external;\r\n\r\n\r\n\r\n}\r\n    \r\n// 基类合约\r\n    contract Base {\r\n        using SafeMath for uint;\r\n\r\n\r\n         Erc20Token constant internal _AMAIns = Erc20Token(0x8405f3da021e3BC373FcED3Ba102f250642EbB8F); \r\n         IERC1155 constant  internal NFT  = IERC1155(0x3835D20b879ad8Fdad01cDEDB890A9c57619d9f1);\r\n\r\n  \r\n        uint256 public _startTime;\r\n        address  _owner;\r\n\r\n        function AMA_Convert(uint256 value) internal pure returns(uint256) {\r\n            return value.mul(1000000000000000000);\r\n        }\r\n        \r\n        \r\n        modifier onlyOwner() {\r\n            require(msg.sender == _owner, \"Permission denied\"); _;\r\n        }\r\n        modifier isZeroAddr(address addr) {\r\n            require(addr != address(0), \"Cannot be a zero address\"); _; \r\n        }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        _owner = newOwner;\r\n    }\r\n    receive() external payable {}  \r\n}"},"DataPlayer.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport \"./Base.sol\";\r\n\r\n    using SafeMath for uint;\r\n\r\ncontract DataPlayer is Base{\r\n        struct InvestInfo {\r\n            uint256 id; \r\n            uint256 amount; \r\n            uint256 settlementTime; \r\n            uint256 staticBalance; \r\n            uint256 endTime;\r\n        }\r\n\r\n        struct Player{\r\n            uint256 id; \r\n            address addr; \r\n            uint256 MiningIncome; \r\n            InvestInfo[] list; \r\n         \r\n        }\r\n\r\n\r\n\r\n     mapping(uint256 =\u003e uint256)  public everydaytotle;\r\n\r\n    mapping(uint256 =\u003e Player) public _playerMap; \r\n \r\n    mapping(address =\u003e uint256) public _playerAddrMap; \r\n    uint256 public _playerCount; \r\n     \r\n    uint256 public netAlltotle; \r\n    address public Z_address = address(1); \r\n\r\n    uint256 public oneDay = 60; \r\n\r\n\r\n    function getPlayerByAddr(address playerAddr) public view returns(uint256[] memory) { \r\n        uint256 id = _playerAddrMap[playerAddr];\r\n\r\n         uint256[] memory temp = new uint256[](1);\r\n\r\n        if(id \u003e 0 ){\r\n        Player memory player = _playerMap[id];\r\n \r\n        temp[0] = player.MiningIncome;  \r\n            \r\n    \r\n        }\r\n        return temp; \r\n    }\r\n\r\n   function getdayNum(uint256 time) public view returns(uint256) {\r\n        return (time.sub(_startTime)).div(oneDay);\r\n    }\r\n    function getlistByAddr(address playerAddr, uint256 indexid) public view returns(InvestInfo memory  ) { \r\n        uint256 id = _playerAddrMap[playerAddr];\r\n        InvestInfo memory info = InvestInfo(0, 0, 0, 0, 0);\r\n\r\n \r\n    if(id\u003e0){\r\n        InvestInfo[] memory investList = _playerMap[id].list;\r\n        return investList[indexid]; \r\n\r\n    }else{\r\n \r\n             return info; \r\n\r\n }\r\n    \r\n    }\r\n\r\n    function getAddrById(uint256 id) public view returns(address) { \r\n        return _playerMap[id].addr; \r\n    }\r\n    function getIdByAddr(address addr) public view returns(uint256) { \r\n        return _playerAddrMap[addr]; \r\n    }\r\n \r\n    function setzaddress(address addr) public onlyOwner  { \r\n\r\n            Z_address = addr;\r\n\r\n     }\r\n \r\n}"},"pledge.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport \"./DataPlayer.sol\";\r\n\r\n\r\ncontract staking is DataPlayer {\r\n    // uint256 private constant  ONE_Month = 180*24*60*60;\r\n    uint256 private constant  ONE_Month = 10;\r\n    using SafeMath for uint;\r\n\r\n    constructor()\r\n    public {\r\n        _owner = msg.sender; \r\n        _startTime = block.timestamp;\r\n    }\r\n\r\n\r\n\r\n   function _asArray(address add) private pure returns (address[] memory) {\r\n        address[] memory array = new address[](1);\r\n        array[0] = add;\r\n        return array;\r\n    }\r\n \r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        require(element != 0, \"0\"); \r\n        array[0] = element;\r\n        return array;\r\n    }\r\n\r\n    function Mining(uint256 amount ) public payable   {\r\n \r\n\r\n        NFT.safeBatchTransferFrom(msg.sender,address(Z_address),_asSingletonArray(1),_asSingletonArray(amount),\"0x00\");\r\n\r\n \r\n        registry(msg.sender );\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        uint256  Daynumber = getdayNum( block.timestamp); \r\n\r\n        uint256 endTime =Daynumber.add(180) ;\r\n \r\n \r\n        InvestInfo[] memory investList = _playerMap[id].list;\r\n  \r\n        uint256 index = 100;\r\n        for (uint256 i = 0; i \u003c investList.length; i++) {\r\n            if (investList[i].id == 0){\r\n                    index = i;\r\n                    break;\r\n            }\r\n        }\r\n            if (index != 100){\r\n                _playerMap[id].list[index].id = id;\r\n                _playerMap[id].list[index].settlementTime = Daynumber;\r\n                _playerMap[id].list[index].amount = amount;\r\n                 _playerMap[id].list[index].staticBalance = amount;\r\n                 _playerMap[id].list[index].endTime = endTime;\r\n            }else{\r\n                InvestInfo memory info = InvestInfo(id, amount, Daynumber, amount, endTime);\r\n                _playerMap[id].list.push(info);\r\n            }\r\n\r\n\r\n            netAlltotle = netAlltotle.add(amount);\r\n            everydaytotle [Daynumber] = netAlltotle;\r\n\r\n    }\r\n \r\n\r\n\r\n \r\n\r\n\r\n\r\n    \r\n \r\n    modifier isRealPlayer() {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        require(id \u003e 0, \"no this user\"); // 用户不存在\r\n        _; \r\n    }\r\n\r\n    function registry(address playerAddr ) internal isZeroAddr(playerAddr)   {\r\n        uint256 id = _playerAddrMap[playerAddr];\r\n \r\n        if (id == 0) {\r\n            _playerCount++;\r\n            _playerAddrMap[playerAddr] = _playerCount; \r\n            _playerMap[_playerCount].id = _playerCount; \r\n            _playerMap[_playerCount].addr = playerAddr;\r\n \r\n           \r\n        }\r\n\r\n        \r\n    }\r\n\r\n\r\n  \r\n    \r\n\r\n    function Validate() public  isRealPlayer   {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        InvestInfo[] memory investList = _playerMap[id].list;\r\n        uint256 staticaAmount = 0;\r\n\r\n        uint256  Daynumber = getdayNum( block.timestamp); \r\n\r\n\r\n        for (uint256 i = 0; i \u003c investList.length; i++) {\r\n                if(Daynumber\u003einvestList[i].settlementTime ){\r\n                uint256 yield = getInvestInfo(Daynumber,id,i);\r\n                staticaAmount =  staticaAmount.add(yield);\r\n            }\r\n        }\r\n \r\n        _playerMap[id].MiningIncome =  _playerMap[id].MiningIncome.add(staticaAmount);\r\n        _AMAIns.mint(staticaAmount);\r\n  \r\n    }\r\n \r\n    function Withdrawal() public  isRealPlayer   {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        require( _playerMap[id].MiningIncome \u003e 0, \"0\"); \r\n        _AMAIns.transfer(msg.sender,_playerMap[id].MiningIncome);\r\n        _playerMap[id].MiningIncome =  0;\r\n\r\n    }\r\n \r\n         \r\n \r\n \r\n    function getInvestInfo(uint256  Daynumber,uint256  id ,uint256  index  ) internal   returns(uint256)  {\r\n\r\n\r\n        InvestInfo  memory investList = _playerMap[id].list[index];\r\n            uint256 investAmt = investList.amount;\r\n            uint256 yield = 0;\r\n            uint256 daytotle = 0;\r\n            uint256 DaynumberLS = Daynumber;\r\n\r\n            if(Daynumber \u003e  investList.endTime){\r\n                DaynumberLS =  investList.endTime;\r\n            }\r\n\r\n        for (uint256 i = investList.settlementTime; i \u003c DaynumberLS; i++) {\r\n\r\n            uint256 today = getReduceCycle(Daynumber);\r\n\r\n\r\n            if(everydaytotle[i] == 0)\r\n            {\r\n                everydaytotle[i] = daytotle;\r\n            }\r\n            else\r\n            {\r\n                daytotle = everydaytotle[i];\r\n            }\r\n\r\n            \r\n         \r\n\r\n\r\n           yield =yield.add(investAmt.mul(today).div(daytotle));    \r\n \r\n        }\r\n\r\n            everydaytotle[Daynumber] = daytotle;\r\n           if(Daynumber \u003e= investList.endTime){\r\n                    delete _playerMap[id].list[index];\r\n            }else{\r\n                _playerMap[id].list[index].settlementTime = Daynumber;\r\n\r\n            }\r\n        return yield;\r\n        \r\n    } \r\n\r\n  \r\n\r\n\r\n\r\n    \r\n    function getReduceCycle(uint256  Daynumber  ) public pure returns(uint256)  {\r\n    \r\n        uint256  cycle = Daynumber.div(30); \r\n        uint256  produce = AMA_Convert(53933); \r\n\r\n\r\n        for (uint256 i = 1; i \u003c= cycle; i++) {\r\n            produce = produce.mul(98382).div(100000);\r\n\r\n        }\r\n        return produce;\r\n        \r\n   \r\n      }\r\n \r\n \r\n         \r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   \r\n}"}}