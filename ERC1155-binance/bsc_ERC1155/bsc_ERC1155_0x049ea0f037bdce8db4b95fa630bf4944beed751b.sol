{"AbstractSale.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./libs.sol\";\nimport \"./Roles.sol\";\nimport \"./ERC165.sol\";\n\n/// @title AbstractSale\n/// @notice Base contract for `ERC721Sale` and `ERC1155Sale`.\ncontract AbstractSale is Ownable {\n    using UintLibrary for uint256;\n    using AddressLibrary for address;\n    using Address for address payable;\n    using StringLibrary for string;\n    using SafeMath for uint256;\n\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\n\n    /// @notice The amount of buyer\u0027s fee. Represented as percents * 100 (100% - 10000. 1% - 100).\n    uint public buyerFee = 0;\n    /// @notice The address to which all the fees are transfered.\n    address payable public beneficiary;\n\n    /* An ECDSA signature. */\n    struct Sig {\n        /* v parameter */\n        uint8 v;\n        /* r parameter */\n        bytes32 r;\n        /* s parameter */\n        bytes32 s;\n    }\n\n    /// @notice The contract constructor.\n    /// @param _beneficiary - The value for `beneficiary`.\n    constructor(address payable _beneficiary) {\n        beneficiary = _beneficiary;\n    }\n\n    /// @notice Set new buyer fee value. Can only be called by the contract owner.\n    ///         Fee value is represented as percents * 100 (100% - 10000. 1% - 100).\n    /// @param _buyerFee - New fee value percents times 100 format.\n    function setBuyerFee(uint256 _buyerFee) public onlyOwner {\n        buyerFee = _buyerFee;\n    }\n\n    /// @notice Set new address as fee recipient. Can only be called by the contract owner.\n    /// @param _beneficiary - New `beneficiary` address.\n    function setBeneficiary(address payable _beneficiary) public onlyOwner {\n        beneficiary = _beneficiary;\n    }\n\n    function prepareMessage(address token, uint256 tokenId, uint256 price, uint256 fee, uint256 nonce) internal pure returns (string memory) {\n        string memory result = string(strConcat(\n                bytes(token.toString()),\n                bytes(\". tokenId: \"),\n                bytes(tokenId.toString()),\n                bytes(\". price: \"),\n                bytes(price.toString()),\n                bytes(\". nonce: \"),\n                bytes(nonce.toString())\n            ));\n        if (fee != 0) {\n            return result.append(\". fee: \", fee.toString());\n        } else {\n            return result;\n        }\n    }\n\n    function strConcat(bytes memory _ba, bytes memory _bb, bytes memory _bc, bytes memory _bd, bytes memory _be, bytes memory _bf, bytes memory _bg) internal pure returns (bytes memory) {\n        bytes memory resultBytes = new bytes(_ba.length + _bb.length + _bc.length + _bd.length + _be.length + _bf.length + _bg.length);\n        uint k = 0;\n        for (uint i = 0; i \u003c _ba.length; i++) resultBytes[k++] = _ba[i];\n        for (uint i = 0; i \u003c _bb.length; i++) resultBytes[k++] = _bb[i];\n        for (uint i = 0; i \u003c _bc.length; i++) resultBytes[k++] = _bc[i];\n        for (uint i = 0; i \u003c _bd.length; i++) resultBytes[k++] = _bd[i];\n        for (uint i = 0; i \u003c _be.length; i++) resultBytes[k++] = _be[i];\n        for (uint i = 0; i \u003c _bf.length; i++) resultBytes[k++] = _bf[i];\n        for (uint i = 0; i \u003c _bg.length; i++) resultBytes[k++] = _bg[i];\n        return resultBytes;\n    }\n\n    function transferEther(IERC165 token, uint256 tokenId, address payable owner, uint256 total, uint256 sellerFee) internal {\n        uint value = transferFeeToBeneficiary(total, sellerFee);\n        if (token.supportsInterface(_INTERFACE_ID_FEES)) {\n            HasSecondarySaleFees withFees = HasSecondarySaleFees(address(token));\n            address payable[] memory recipients = withFees.getFeeRecipients(tokenId);\n            uint[] memory fees = withFees.getFeeBps(tokenId);\n            require(fees.length == recipients.length);\n            for (uint256 i = 0; i \u003c fees.length; i++) {\n                (uint newValue, uint current) = subFee(value, total.mul(fees[i]).div(10000));\n                value = newValue;\n                recipients[i].sendValue(current);\n            }\n        }\n        owner.sendValue(value);\n    }\n\n    function transferFeeToBeneficiary(uint total, uint sellerFee) internal returns (uint) {\n        (uint value, uint sellerFeeValue) = subFee(total, total.mul(sellerFee).div(10000));\n        uint buyerFeeValue = total.mul(buyerFee).div(10000);\n        uint beneficiaryFee = buyerFeeValue.add(sellerFeeValue);\n        if (beneficiaryFee \u003e 0) {\n            beneficiary.sendValue(beneficiaryFee);\n        }\n        return value;\n    }\n\n    function subFee(uint value, uint fee) internal pure returns (uint newValue, uint realFee) {\n        if (value \u003e fee) {\n            newValue = value - fee;\n            realFee = fee;\n        } else {\n            newValue = 0;\n            realFee = value;\n        }\n    }\n}\n\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"},"DIERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract DIERC20 {\n    function transferFrom(address from, address to, uint value) virtual external;\n}\n"},"ERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\nimport \"./Roles.sol\";\nimport \"./HasTokenURI.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller\u0027s tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``\u0027s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\u0027s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n/**\n    Note: Simple contract to use as base for const vals\n*/\ncontract CommonConstants {\n\n    bytes4 constant internal ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 constant internal ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n}\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n*/\ninterface ERC1155TokenReceiver {\n    /**\n        @notice Handle the receipt of a single ERC1155 token type.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n        This function MUST revert if it rejects the transfer.\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _id        The ID of the token being transferred\n        @param _value     The amount of tokens being transferred\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    */\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\n\n    /**\n        @notice Handle the receipt of multiple ERC1155 token types.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n        This function MUST revert if it rejects the transfer(s).\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    */\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\n*/\ninterface IERC1155Metadata_URI {\n    /**\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\n        @dev URIs are defined in RFC 3986.\n        The URI may point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n        @return URI string\n    */\n    function uri(uint256 _id) external view returns (string memory);\n}\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\n*/\ncontract ERC1155Metadata_URI is IERC1155Metadata_URI, HasTokenURI {\n\n    constructor(string memory _tokenURIPrefix) HasTokenURI(_tokenURIPrefix) {\n\n    }\n\n    function uri(uint256 _id) external override view returns (string memory) {\n        return _tokenURI(_id);\n    }\n}\n\ncontract ERC1155 is IERC1155, ERC165Storage, CommonConstants\n{\n    using SafeMath for uint256;\n    using Address for address;\n\n    // id =\u003e (owner =\u003e balance)\n    mapping (uint256 =\u003e mapping(address =\u003e uint256)) internal balances;\n\n    // owner =\u003e (operator =\u003e approved)\n    mapping (address =\u003e mapping(address =\u003e bool)) internal operatorApproval;\n\n/////////////////////////////////////////// ERC165 //////////////////////////////////////////////\n\n    /*\n        bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")) ^\n        bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")) ^\n        bytes4(keccak256(\"balanceOf(address,uint256)\")) ^\n        bytes4(keccak256(\"balanceOfBatch(address[],uint256[])\")) ^\n        bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^\n        bytes4(keccak256(\"isApprovedForAll(address,address)\"));\n    */\n    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n\n/////////////////////////////////////////// CONSTRUCTOR //////////////////////////////////////////\n\n    constructor() {\n        _registerInterface(INTERFACE_SIGNATURE_ERC1155);\n    }\n\n/////////////////////////////////////////// ERC1155 //////////////////////////////////////////////\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size \u003e 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _id      ID of the token type\n        @param _value   Transfer amount\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) override external {\n\n        require(_to != address(0x0), \"_to must be non-zero.\");\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n\n        // SafeMath will throw with insuficient funds _from\n        // or if _id is not valid (balance will be 0)\n        balances[_id][_from] = balances[_id][_from].sub(_value);\n        balances[_id][_to]   = _value.add(balances[_id][_to]);\n\n        // MUST emit event\n        emit TransferSingle(msg.sender, _from, _to, _id, _value);\n\n        // Now that the balance is updated and the event was emitted,\n        // call onERC1155Received if the destination is a contract.\n        if (_to.isContract()) {\n            _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\n        }\n    }\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size \u003e 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     IDs of each token type (order and length must match _values array)\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) override external {\n\n        // MUST Throw on errors\n        require(_to != address(0x0), \"destination address must be non-zero.\");\n        require(_ids.length == _values.length, \"_ids and _values array lenght must match.\");\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\n\n        for (uint256 i = 0; i \u003c _ids.length; ++i) {\n            uint256 id = _ids[i];\n            uint256 value = _values[i];\n\n            // SafeMath will throw with insuficient funds _from\n            // or if _id is not valid (balance will be 0)\n            balances[id][_from] = balances[id][_from].sub(value);\n            balances[id][_to]   = value.add(balances[id][_to]);\n        }\n\n        // Note: instead of the below batch versions of event and acceptance check you MAY have emitted a TransferSingle\n        // event and a subsequent call to _doSafeTransferAcceptanceCheck in above loop for each balance change instead.\n        // Or emitted a TransferSingle event for each in the loop and then the single _doSafeBatchTransferAcceptanceCheck below.\n        // However it is implemented the balance changes and events MUST match when a check (i.e. calling an external contract) is done.\n\n        // MUST emit event\n        emit TransferBatch(msg.sender, _from, _to, _ids, _values);\n\n        // Now that the balances are updated and the events are emitted,\n        // call onERC1155BatchReceived if the destination is a contract.\n        if (_to.isContract()) {\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data);\n        }\n    }\n\n    /**\n        @notice Get the balance of an account\u0027s Tokens.\n        @param _owner  The address of the token holder\n        @param _id     ID of the Token\n        @return        The _owner\u0027s balance of the Token type requested\n     */\n    function balanceOf(address _owner, uint256 _id) override external view returns (uint256) {\n        // The balance of any account can be calculated from the Transfer events history.\n        // However, since we need to keep the balances to validate transfer request,\n        // there is no extra cost to also privide a querry function.\n        return balances[_id][_owner];\n    }\n\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param _owners The addresses of the token holders\n        @param _ids    ID of the Tokens\n        @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) override external view returns (uint256[] memory) {\n        require(_owners.length == _ids.length, \"[ERC1155] Lengths of the array are not the same\");\n\n        uint256[] memory balances_ = new uint256[](_owners.length);\n\n        for (uint256 i = 0; i \u003c _owners.length; ++i) {\n            balances_[i] = balances[_ids[i]][_owners[i]];\n        }\n\n        return balances_;\n    }\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller\u0027s tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param _operator  Address to add to the set of authorized operators\n        @param _approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address _operator, bool _approved) override external {\n        operatorApproval[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param _owner     The owner of the Tokens\n        @param _operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address _owner, address _operator) override external view returns (bool) {\n        return operatorApproval[_owner][_operator];\n    }\n\n/////////////////////////////////////////// Internal //////////////////////////////////////////////\n\n    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\n\n        // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by\n        // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn\u0027t a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance.\n\n\n        // Note: if the below reverts in the onERC1155Received function of the _to address you will have an undefined revert reason returned rather than the one in the require test.\n        // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_ACCEPTED test.\n        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\n\n        // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by\n        // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn\u0027t a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance.\n\n        // Note: if the below reverts in the onERC1155BatchReceived function of the _to address you will have an undefined revert reason returned rather than the one in the require test.\n        // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_BATCH_ACCEPTED test.\n        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\n    }\n    \n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Storage) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155Metadata_URI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n\ncontract ERC1155Base is HasSecondarySaleFees, Ownable, ERC1155Metadata_URI, HasContractURI, ERC1155 {\n    using SafeMath for uint256;\n    \n    struct Fee {\n        address payable recipient;\n        uint256 value;\n    }\n\n    /// @notice id =\u003e creator\n    mapping (uint256 =\u003e address) public creators;\n    /// @notice id =\u003e fees\n    mapping (uint256 =\u003e Fee[]) public fees;\n\n    constructor(string memory contractURI, string memory tokenURIPrefix) HasContractURI(contractURI) ERC1155Metadata_URI(tokenURIPrefix) {\n\n    }\n\n    /**\n        @notice     Get the secondary fee recipients of the token.\n        @param id - The id of the token.\n        @return     An array of fee recipient addresses.\n    */\n    function getFeeRecipients(uint256 id) override public view returns (address payable[] memory) {\n        Fee[] memory _fees = fees[id];\n        address payable[] memory result = new address payable[](_fees.length);\n        for (uint i = 0; i \u003c _fees.length; i++) {\n            result[i] = _fees[i].recipient;\n        }\n        return result;\n    }\n\n    /**\n        @notice     Get the secondary fee amounts of the token.\n        @param id - The id of the token.\n        @return     An array of fee amount values.\n    */\n    function getFeeBps(uint256 id) override public view returns (uint[] memory) {\n        Fee[] memory _fees = fees[id];\n        uint[] memory result = new uint[](_fees.length);\n        for (uint i = 0; i \u003c _fees.length; i++) {\n            result[i] = _fees[i].value;\n        }\n        return result;\n    }\n\n    /// @notice Creates a new token type and assings _initialSupply to minter\n    function _mint(uint256 _id, Fee[] memory _fees, uint256 _supply, string memory _uri) internal {\n        require(creators[_id] == address(0x0), \"Token is already minted\");\n        require(_supply != 0, \"Supply should be positive\");\n        require(bytes(_uri).length \u003e 0, \"uri should be set\");\n\n        creators[_id] = msg.sender;\n        address[] memory recipients = new address[](_fees.length);\n        uint[] memory bps = new uint[](_fees.length);\n        for (uint i = 0; i \u003c _fees.length; i++) {\n            require(_fees[i].recipient != address(0x0), \"Recipient should be present\");\n            require(_fees[i].value != 0, \"Fee value should be positive\");\n            fees[_id].push(_fees[i]);\n            recipients[i] = _fees[i].recipient;\n            bps[i] = _fees[i].value;\n        }\n        if (_fees.length \u003e 0) {\n            emit SecondarySaleFees(_id, recipients, bps);\n        }\n        balances[_id][msg.sender] = _supply;\n        _setTokenURI(_id, _uri);\n\n        // Transfer event with mint semantic\n        emit TransferSingle(msg.sender, address(0x0), msg.sender, _id, _supply);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Burns the token.\n    function burn(address _owner, uint256 _id, uint256 _value) external {\n\n        require(_owner == msg.sender || operatorApproval[_owner][msg.sender] == true, \"Need operator approval for 3rd party burns.\");\n\n        // SafeMath will throw with insuficient funds _owner\n        // or if _id is not valid (balance will be 0)\n        balances[_id][_owner] = balances[_id][_owner].sub(_value);\n\n        // MUST emit event\n        emit TransferSingle(msg.sender, _owner, address(0x0), _id, _value);\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) override internal {\n        require(creators[tokenId] != address(0x0), \"_setTokenURI: Token should exist\");\n        super._setTokenURI(tokenId, uri);\n        emit URI(uri, tokenId);\n    }\n\n    /// @notice Sets the URI prefix for all tokens.\n    function setTokenURIPrefix(string memory tokenURIPrefix) public onlyOwner {\n        _setTokenURIPrefix(tokenURIPrefix);\n    }\n\n    /// @notice Sets the URI of the contract metadata.\n    function setContractURI(string memory contractURI) public onlyOwner {\n        _setContractURI(contractURI);\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, ERC165Storage) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155Metadata_URI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n\n"},"ERC1155Sale.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Roles.sol\";\nimport \"./ERC1155.sol\";\nimport \"./AbstractSale.sol\";\nimport \"./TransferProxy.sol\";\n\n/// @title ERC1155SaleNonceHolder\n/// @notice The contract manages nonce values for the sales.\ncontract ERC1155SaleNonceHolder is OwnableOperatorRole {\n    /// @notice Token nonces.\n    /// @dev keccak256(token, owner, tokenId) =\u003e nonce\n    mapping(bytes32 =\u003e uint256) public nonces;\n\n    /// @notice The amount of selled tokens for the tokenId.\n    /// @dev keccak256(token, owner, tokenId, nonce) =\u003e completed amount\n    mapping(bytes32 =\u003e uint256) public completed;\n\n    /// @notice Get nonce value for the token.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @param owner - The address of the token owner.\n    /// @return The nonce value.\n    function getNonce(address token, uint256 tokenId, address owner) view public returns (uint256) {\n        return nonces[getNonceKey(token, tokenId, owner)];\n    }\n\n    /// @notice Sets new nonce value for the token. Can only be called by the operator.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @param owner - The address of the token owner.\n    /// @param nonce - The new value for the nonce.\n    function setNonce(address token, uint256 tokenId, address owner, uint256 nonce) public onlyOperator {\n        nonces[getNonceKey(token, tokenId, owner)] = nonce;\n    }\n\n    /// @notice Encode the token info to use as a key for `nonces` mapping.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @param owner - The address of the token owner.\n    /// @return Encoded key for the token.\n    function getNonceKey(address token, uint256 tokenId, address owner) pure public returns (bytes32) {\n        return keccak256(abi.encodePacked(token, tokenId, owner));\n    }\n\n    /// @notice Get the amount of selled tokens.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @param owner - The address of the token owner.\n    /// @param nonce - The nonce value of the sale.\n    /// @return Selled tokens count for the sale with specific nonce.\n    function getCompleted(address token, uint256 tokenId, address owner, uint256 nonce) view public returns (uint256) {\n        return completed[getCompletedKey(token, tokenId, owner, nonce)];\n    }\n\n    /// @notice Sets the new amount of selled tokens. Can be called only by the contract operator.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @param owner - The address of the token owner.\n    /// @param nonce - The nonce value of the sale.\n    /// @param _completed - The new completed value to set.\n    function setCompleted(address token, uint256 tokenId, address owner, uint256 nonce, uint256 _completed) public onlyOperator {\n        completed[getCompletedKey(token, tokenId, owner, nonce)] = _completed;\n    }\n\n    /// @notice Encode order key to use as a key of `completed` mapping.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @param owner - The address of the token owner.\n    /// @param nonce - The nonce value of the sale.\n    /// @return Encoded key.\n    function getCompletedKey(address token, uint256 tokenId, address owner, uint256 nonce) pure public returns (bytes32) {\n        return keccak256(abi.encodePacked(token, tokenId, owner, nonce));\n    }\n}\n\n/// @title ERC1155Sale\n/// @notice Allows users to exchange ERC1155Sale tokens for the Ether.\ncontract ERC1155Sale is Ownable, AbstractSale {\n    using StringLibrary for string;\n    using SafeMath for uint256;\n    using UintLibrary for uint256;\n    using Address for address payable;\n\n    event CloseOrder(address indexed token, uint256 indexed tokenId, address owner, uint256 nonce);\n    event Buy(address indexed token, uint256 indexed tokenId, address owner, uint256 price, address buyer, uint256 value);\n\n    bytes constant EMPTY = \"\";\n\n    /// @notice The address of a transfer proxy for ERC721 and ERC1155 tokens.\n    TransferProxy public transferProxy;\n    /// @notice The address of a nonce manager contract.\n    ERC1155SaleNonceHolder public nonceHolder;\n\n    /// @param _transferProxy - The address of a deployed TransferProxy contract.\n    /// @param _nonceHolder - The address of a deployed ERC1155SaleNonceHolder contract.\n    /// @param beneficiary - The address of a fee recipient.\n    constructor(TransferProxy _transferProxy, ERC1155SaleNonceHolder _nonceHolder, address payable beneficiary) AbstractSale(beneficiary) {\n        transferProxy = _transferProxy;\n        nonceHolder = _nonceHolder;\n    }\n\n    /// @notice This function is called to buy ERC1151 token in exchange for ETH.\n    /// @notice ERC1155 token must be approved for this contract before calling this function.\n    /// @notice To pay with ETH, transaction must send ether within the calling transaction.\n    /// @notice Buyer\u0027s payment value is calculated as `price * buying + buyerFee%`. `buyerFee` can be obtaind by calling buyerFee() function of this contract (inherited from AbstractSale).\n    /// @param token - ERC1151 token contracy address.\n    /// @param tokenId - ERC1151 token id for sale.\n    /// @param owner - The address of the ERC1151 token owner.\n    /// @param selling - The total amount of ERC1155 token for sale.\n    /// @param buying - The amount of ERC1155 tokens to buy in this function call.\n    /// @param price - The price of ERC1151 token in WEI.\n    /// @param sellerFee - Amount for seller\u0027s fee. Represented as percents * 100 (100% =\u003e 10000. 1% =\u003e 100).\n    /// @param signature - Signed message with parameters of the format: `${token.address.toLowerCase()}. tokenId: ${tokenId}. price: ${price}. nonce: ${nonce}. fee: ${sellerFee}. value: ${selling}`\n    ///        If sellerFee is zero, than the format is `${token.address.toLowerCase()}. tokenId: ${tokenId}. price: ${price}. nonce: ${nonce}. value: ${selling}`\n    ///        Where token.address.toLowerCase() is the address of the ERC1151 token contract (parameter `value`).\n    ///        The `nonce` can be obtained from the nonceHolder with `getNonce` function.\n    ///        Message must be prefixed with: `\"\\x19Ethereum Signed Message:\\n\" + message.length`.\n    ///        Some libraries, for example web3.accounts.sign, will automatically prefix the message.\n    function buy(IERC1155 token, uint256 tokenId, address payable owner, uint256 selling, uint256 buying, uint256 price, uint256 sellerFee, Sig memory signature) public payable {\n        uint256 nonce = verifySignature(address(token), tokenId, owner, selling, price, sellerFee, signature);\n        uint256 total = price.mul(buying);\n        uint256 buyerFeeValue = total.mul(buyerFee).div(10000);\n        require(total + buyerFeeValue \u003c= msg.value, \"msg.value is incorrect\");\n        bool closed = verifyOpenAndModifyState(address(token), tokenId, owner, nonce, selling, buying);\n\n        transferProxy.erc1155safeTransferFrom(token, owner, msg.sender, tokenId, buying, EMPTY);\n\n        transferEther(token, tokenId, owner, total, sellerFee);\n        \n        payable(msg.sender).sendValue(msg.value - (total + buyerFeeValue));\n        emit Buy(address(token), tokenId, owner, price, msg.sender, buying);\n        if (closed) {\n            emit CloseOrder(address(token), tokenId, owner, nonce + 1);\n        }\n    }\n\n    /// @notice Cancel the token sale order. Can be called only by the token owner.\n    ///         The function makes signed buy message invalid by increasing the nonce for the token.\n    /// @param token - The address of the token contract.\n    /// @param tokenId - The token id.\n    function cancel(address token, uint256 tokenId) public payable {\n        uint nonce = nonceHolder.getNonce(token, tokenId, msg.sender);\n        nonceHolder.setNonce(token, tokenId, msg.sender, nonce + 1);\n\n        emit CloseOrder(token, tokenId, msg.sender, nonce + 1);\n    }\n\n    function verifySignature(address token, uint256 tokenId, address payable owner, uint256 selling, uint256 price, uint256 sellerFee, Sig memory signature) view internal returns (uint256 nonce) {\n        nonce = nonceHolder.getNonce(token, tokenId, owner);\n        require(prepareMessage(token, tokenId, price, selling, sellerFee, nonce).recover(signature.v, signature.r, signature.s) == owner, \"incorrect signature\");\n    }\n\n    function verifyOpenAndModifyState(address token, uint256 tokenId, address payable owner, uint256 nonce, uint256 selling, uint256 buying) internal returns (bool) {\n        uint comp = nonceHolder.getCompleted(token, tokenId, owner, nonce).add(buying);\n        require(comp \u003c= selling, \"[ERC1155Sale] Not enough for buying\");\n        nonceHolder.setCompleted(token, tokenId, owner, nonce, comp);\n\n        if (comp == selling) {\n            nonceHolder.setNonce(token, tokenId, owner, nonce + 1);\n            return true;\n        }\n        return false;\n    }\n\n    function prepareMessage(address token, uint256 tokenId, uint256 price, uint256 value, uint256 fee, uint256 nonce) internal pure returns (string memory) {\n        return prepareMessage(token, tokenId, price, fee, nonce).append(\". value: \", value.toString());\n    }\n}\n"},"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it\u0027s supported.\n     */\n    mapping(bytes4 =\u003e bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\ncontract HasContractURI is ERC165Storage {\n\n    string public contractURI;\n\n    /*\n     * bytes4(keccak256(\u0027contractURI()\u0027)) == 0xe8a3d485\n     */\n    bytes4 private constant _INTERFACE_ID_CONTRACT_URI = 0xe8a3d485;\n\n    constructor(string memory _contractURI)  {\n        contractURI = _contractURI;\n        _registerInterface(_INTERFACE_ID_CONTRACT_URI);\n    }\n\n    /**\n     * @dev Internal function to set the contract URI\n     * @param _contractURI string URI prefix to assign\n     */\n    function _setContractURI(string memory _contractURI) internal {\n        contractURI = _contractURI;\n    }\n}\n\nabstract contract HasSecondarySaleFees is ERC165Storage {\n\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\n\n    /*\n     * bytes4(keccak256(\u0027getFeeBps(uint256)\u0027)) == 0x0ebd4c7f\n     * bytes4(keccak256(\u0027getFeeRecipients(uint256)\u0027)) == 0xb9c4d9fb\n     *\n     * =\u003e 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\n     */\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\n\n    constructor() {\n        _registerInterface(_INTERFACE_ID_FEES);\n    }\n\n    function getFeeRecipients(uint256 id) public virtual view returns (address payable[] memory);\n    function getFeeBps(uint256 id) public virtual view returns (uint[] memory);\n}\n"},"ERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.3.2 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./libs.sol\";\nimport \"./Roles.sol\";\nimport \"./HasTokenURI.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165Storage, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 =\u003e address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address =\u003e uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 =\u003e address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Storage, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n    \n    function _burn(address owner, uint256 tokenId) internal virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(owner, tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n    }\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``\u0027s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 =\u003e uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 =\u003e uint256) private _allTokensIndex;\n\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index \u003c ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index \u003c ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension\u0027s ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension\u0027s token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension\u0027s ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from\u0027s tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension\u0027s token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an \u0027if\u0027 statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n/**\n * @title Full ERC721 Token with support for tokenURIPrefix\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Base is HasSecondarySaleFees, HasContractURI, HasTokenURI, ERC721Enumerable {\n\n    /**\n        @notice Describes a fee.\n        @param recipient - Fee recipient address.\n        @param value - Fee amount in percents * 100.\n    */\n    struct Fee {\n        address payable recipient;\n        uint256 value;\n    }\n\n    // id =\u003e fees\n    mapping (uint256 =\u003e Fee[]) public fees;\n\n    /*\n     *     bytes4(keccak256(\u0027name()\u0027)) == 0x06fdde03\n     *     bytes4(keccak256(\u0027symbol()\u0027)) == 0x95d89b41\n     *     bytes4(keccak256(\u0027tokenURI(uint256)\u0027)) == 0xc87b56dd\n     *\n     *     =\u003e 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory _name, string memory _symbol, string memory contractURI, string memory _tokenURIPrefix)  ERC721(_name, _symbol) HasContractURI(contractURI) HasTokenURI(_tokenURIPrefix) {\n\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n        @notice     Get the secondary fee recipients of the token.\n        @param id - The id of the token.\n        @return     An array of fee recipient addresses.\n    */\n    function getFeeRecipients(uint256 id) public override view returns (address payable[] memory) {\n        Fee[] memory _fees = fees[id];\n        address payable[] memory result = new address payable[](_fees.length);\n        for (uint i = 0; i \u003c _fees.length; i++) {\n            result[i] = _fees[i].recipient;\n        }\n        return result;\n    }\n\n    /**\n        @notice     Get the secondary fee amounts of the token.\n        @param id - The id of the token.\n        @return     An array of fee amount values.\n    */\n    function getFeeBps(uint256 id) public override view returns (uint[] memory) {\n        Fee[] memory _fees = fees[id];\n        uint[] memory result = new uint[](_fees.length);\n        for (uint i = 0; i \u003c _fees.length; i++) {\n            result[i] = _fees[i].value;\n        }\n        return result;\n    }\n\n    function _mint(address to, uint256 tokenId, Fee[] memory _fees) internal {\n        _mint(to, tokenId);\n        address[] memory recipients = new address[](_fees.length);\n        uint[] memory bps = new uint[](_fees.length);\n        for (uint i = 0; i \u003c _fees.length; i++) {\n            require(_fees[i].recipient != address(0x0), \"Recipient should be present\");\n            require(_fees[i].value != 0, \"Fee value should be positive\");\n            fees[tokenId].push(_fees[i]);\n            recipients[i] = _fees[i].recipient;\n            bps[i] = _fees[i].value;\n        }\n        if (_fees.length \u003e 0) {\n            emit SecondarySaleFees(tokenId, recipients, bps);\n        }\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID.\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) public override view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        return super._tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) override internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        super._setTokenURI(tokenId, uri);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal override {\n        super._burn(owner, tokenId);\n        _clearTokenURI(tokenId);\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC165Storage) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721Base {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}"},"ERC721Sale.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Roles.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC1155.sol\";\nimport \"./AbstractSale.sol\";\nimport \"./TransferProxy.sol\";\n\n/// @title IERC721Sale\nabstract contract IERC721Sale {\n    function getNonce(IERC721 token, uint256 tokenId) view virtual public returns (uint256);\n}\n\n/// @title ERC721SaleNonceHolder\n/// @notice The contract manages nonce values for the sales.\ncontract ERC721SaleNonceHolder is OwnableOperatorRole {\n    /// @notice token nonces\n    mapping(bytes32 =\u003e uint256) public nonces;\n    /// @notice Previous nonce manager contract address.\n    IERC721Sale public previous;\n\n    /// @notice The contract constructor.\n    /// @param _previous - The value of the previous nonce manager contract.\n    constructor(IERC721Sale _previous) {\n        previous = _previous;\n    }\n\n    /// @notice Get nonce value for the token.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @return The nonce value.\n    function getNonce(IERC721 token, uint256 tokenId) view public returns (uint256) {\n        uint256 newNonce = nonces[getPositionKey(token, tokenId)];\n        if (newNonce != 0) {\n            return newNonce;\n        }\n        if (address(previous) == address(0x0)) {\n            return 0;\n        }\n        return previous.getNonce(token, tokenId);\n    }\n\n    /// @notice Sets new nonce value for the token. Can only be called by the operator.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @param nonce - The new value for the nonce.\n    function setNonce(IERC721 token, uint256 tokenId, uint256 nonce) public onlyOperator {\n        nonces[getPositionKey(token, tokenId)] = nonce;\n    }\n\n    /// @notice Encode the token info to use as a mapping key.\n    /// @param token - Token\u0027s contract address.\n    /// @param tokenId - Token id.\n    /// @return Encoded key for the token.\n    function getPositionKey(IERC721 token, uint256 tokenId) pure public returns (bytes32) {\n        return keccak256(abi.encodePacked(token, tokenId));\n    }\n}\n\n/// @title ERC721Sale\n/// @notice Allows users to exchange ERC721 tokens for the Ether.\ncontract ERC721Sale is Ownable, IERC721Receiver, AbstractSale {\n    using AddressLibrary for address;\n    using UintLibrary for uint256;\n    using StringLibrary for string;\n    using SafeMath for uint256;\n    using Address for address payable;\n\n    event Cancel(address indexed token, uint256 indexed tokenId, address owner, uint256 nonce);\n    event Buy(address indexed token, uint256 indexed tokenId, address seller, address buyer, uint256 price, uint256 nonce);\n\n    /// @notice The address of a transfer proxy for ERC721 and ERC1155 tokens.\n    TransferProxy public transferProxy;\n    /// @notice The address of a nonce manager contract.\n    ERC721SaleNonceHolder public nonceHolder;\n\n    /// @param _transferProxy - The address of a deployed TransferProxy contract.\n    /// @param _nonceHolder - The address of a deployed ERC721SaleNonceHolder contract.\n    /// @param beneficiary - The address of a fee recipient.\n    constructor(TransferProxy _transferProxy, ERC721SaleNonceHolder _nonceHolder, address payable beneficiary) AbstractSale(beneficiary) {\n        transferProxy = _transferProxy;\n        nonceHolder = _nonceHolder;\n    }\n\n    /// @notice Cancel the token sale order. Can be called only by the token owner.\n    ///         The function makes signed buy message invalid by increasing the nonce for the token.\n    /// @param token - The address of the token contract.\n    /// @param tokenId - The token id.\n    function cancel(IERC721 token, uint256 tokenId) public {\n        address owner = token.ownerOf(tokenId);\n        require(owner == msg.sender, \"not an owner\");\n        uint256 nonce = nonceHolder.getNonce(token, tokenId) + 1;\n        nonceHolder.setNonce(token, tokenId, nonce);\n        emit Cancel(address(token), tokenId, owner, nonce);\n    }\n\n    /// @notice This function is called to buy ERC721 token in exchange for ETH.\n    /// @notice ERC721 token must be approved for this contract before calling this function.\n    /// @notice To pay with ETH, transaction must send ether within the calling transaction.\n    /// @notice Buyer\u0027s payment value is calculated as `price + buyerFee%`. `buyerFee` can be obtaind by calling buyerFee() function of this contract (inherited from AbstractSale).\n    /// @param token - ERC721 token contracy address.\n    /// @param tokenId - ERC721 token id for sale.\n    /// @param price - The price of ERC721 token in WEI.\n    /// @param sellerFee - Amount for seller\u0027s fee. Represented as percents * 100 (100% =\u003e 10000. 1% =\u003e 100).\n    /// @param signature - Signed message with parameters of the format: `${token.address.toLowerCase()}. tokenId: ${tokenId}. price: ${price}. nonce: ${nonce}. fee: ${sellerFee}`\n    ///        If sellerFee is zero, than the format is `${token.address.toLowerCase()}. tokenId: ${tokenId}. price: ${price}. nonce: ${nonce}`\n    ///        Where token.address.toLowerCase() is the address of the ERC721 token contract (parameter `value`).\n    ///        The `nonce` can be obtained from the nonceHolder with `getNonce` function.\n    ///        Message must be prefixed with: `\"\\x19Ethereum Signed Message:\\n\" + message.length`.\n    ///        Some libraries, for example web3.accounts.sign, will automatically prefix the message.\n    function buy(IERC721 token, uint256 tokenId, uint256 price, uint256 sellerFee, Sig memory signature) public payable {\n        address payable owner = payable(token.ownerOf(tokenId));\n        uint256 nonce = nonceHolder.getNonce(token, tokenId);\n        uint256 buyerFeeValue = price.mul(buyerFee).div(10000);\n        require(msg.value \u003e= price + buyerFeeValue, \"msg.value is incorrect\");\n        require(owner == prepareMessage(address(token), tokenId, price, sellerFee, nonce).recover(signature.v, signature.r, signature.s), \"owner should sign correct message\");\n        transferProxy.erc721safeTransferFrom(token, owner, msg.sender, tokenId);\n        transferEther(token, tokenId, owner, price, sellerFee);\n        nonceHolder.setNonce(token, tokenId, nonce + 1);\n        payable(msg.sender).sendValue(msg.value - (price+buyerFeeValue));\n        emit Buy(address(token), tokenId, owner, msg.sender, price, nonce + 1);\n    }\n\n    /// @notice Standard ERC721 receiver function implementation.\n    function onERC721Received(address, address, uint256, bytes memory) public pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"},"ExchangeV1.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./libs.sol\";\nimport \"./Roles.sol\";\nimport \"./ERC165.sol\";\nimport \"./IERC20.sol\";\nimport \"./DIERC20.sol\";\nimport \"./TransferProxy.sol\";\n\n/// @title ExchangeDomainV1\n/// @notice Describes all the structs that are used in exchnages.\ncontract ExchangeDomainV1 {\n\n    enum AssetType {ETH, ERC20, ERC20Deprecated, BEP20, ERC1155, ERC721, ERC721Deprecated}\n\n    struct Asset {\n        address token;\n        uint tokenId;\n        AssetType assetType;\n    }\n\n    struct OrderKey {\n        /* who signed the order */\n        address owner;\n        /* random number */\n        uint salt;\n\n        /* what has owner */\n        Asset sellAsset;\n\n        /* what wants owner */\n        Asset buyAsset;\n    }\n\n    struct Order {\n        OrderKey key;\n\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\n        uint selling;\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\n        uint buying;\n\n        /* fee for selling. Represented as percents * 100 (100% - 10000. 1% - 100)*/\n        uint sellerFee;\n    }\n\n    /* An ECDSA signature. */\n    struct Sig {\n        /* v parameter */\n        uint8 v;\n        /* r parameter */\n        bytes32 r;\n        /* s parameter */\n        bytes32 s;\n    }\n}\n\n/// @title ExchangeStateV1\n/// @notice Tracks the amount of selled tokens in the order.\ncontract ExchangeStateV1 is OwnableOperatorRole {\n\n    // keccak256(OrderKey) =\u003e completed\n    mapping(bytes32 =\u003e uint256) public completed;\n    \n    address public previousStateAddress;\n\n    /// @notice Get the amount of selled tokens.\n    /// @param key - the `OrderKey` struct.\n    /// @return Selled tokens count for the order.\n    function getCompleted(ExchangeDomainV1.OrderKey calldata key) view external returns (uint256) {\n        uint256 result = completed[getCompletedKey(key)];\n        if(previousStateAddress != address(0)) {\n              result += ExchangeStateV1(previousStateAddress).getCompleted(key);\n        }\n        return result;\n    }\n\n    /// @notice Sets the new amount of selled tokens. Can be called only by the contract operator.\n    /// @param key - the `OrderKey` struct.\n    /// @param newCompleted - The new value to set.\n    function setCompleted(ExchangeDomainV1.OrderKey calldata key, uint256 newCompleted) external onlyOperator {\n        completed[getCompletedKey(key)] = newCompleted;\n    }\n\n    /// @notice Encode order key to use as the mapping key.\n    /// @param key - the `OrderKey` struct.\n    /// @return Encoded order key.\n    function getCompletedKey(ExchangeDomainV1.OrderKey memory key) pure public returns (bytes32) {\n        return keccak256(abi.encodePacked(key.owner, key.sellAsset.token, key.sellAsset.tokenId, key.buyAsset.token, key.buyAsset.tokenId, key.salt));\n    }\n    \n    function setPreviousState(address _previousStateAddress) external onlyOwner {\n        previousStateAddress = _previousStateAddress;\n    }\n}\n\n/// @title ExchangeOrdersHolderV1\n/// @notice Optionally holds orders, which can be exchanged without order\u0027s holder signature.\ncontract ExchangeOrdersHolderV1 {\n\n    mapping(bytes32 =\u003e OrderParams) internal orders;\n\n    struct OrderParams {\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\n        uint selling;\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\n        uint buying;\n\n        /* fee for selling */\n        uint sellerFee;\n    }\n\n    /// @notice This function can be called to add the order to the contract, so it can be exchanged without signature.\n    ///         Can be called only by the order owner.\n    /// @param order - The order struct to add.\n    function add(ExchangeDomainV1.Order calldata order) external {\n        require(msg.sender == order.key.owner, \"order could be added by owner only\");\n        bytes32 key = prepareKey(order);\n        require(orders[key].selling == 0 \u0026\u0026 orders[key].buying == 0 \u0026\u0026 orders[key].sellerFee == 0, \"Order is already existed. Try to change salt\");\n        orders[key] = OrderParams(order.selling, order.buying, order.sellerFee);\n    }\n\n    /// @notice This function checks if order was added to the orders holder contract.\n    /// @param order - The order struct to check.\n    /// @return true if order is present in the contract\u0027s data.\n    function exists(ExchangeDomainV1.Order calldata order) external view returns (bool) {\n        bytes32 key = prepareKey(order);\n        OrderParams memory params = orders[key];\n        return params.buying == order.buying \u0026\u0026 params.selling == order.selling \u0026\u0026 params.sellerFee == order.sellerFee;\n    }\n\n    function prepareKey(ExchangeDomainV1.Order memory order) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                order.key.sellAsset.token,\n                order.key.sellAsset.tokenId,\n                order.key.owner,\n                order.key.buyAsset.token,\n                order.key.buyAsset.tokenId,\n                order.key.salt\n            ));\n    }\n}\n\n/// @title Token Exchange contract.\n/// @notice Supports ETH, ERC20, ERC721 and ERC1155 tokens.\n/// @notice This contracts relies on offchain signatures for order and fees verification.\ncontract ExchangeV1 is Ownable, ExchangeDomainV1 {\n    using SafeMath for uint;\n    using UintLibrary for uint;\n    using StringLibrary for string;\n    using BytesLibrary for bytes32;\n    using Address for address payable;\n\n    enum FeeSide {NONE, SELL, BUY}\n\n    event Buy(\n        address indexed sellToken, uint256 indexed sellTokenId, uint256 sellValue,\n        address owner,\n        address buyToken, uint256 buyTokenId, uint256 buyValue,\n        address buyer,\n        uint256 amount,\n        uint256 salt\n    );\n\n    event Cancel(\n        address indexed sellToken, uint256 indexed sellTokenId,\n        address owner,\n        address buyToken, uint256 buyTokenId,\n        uint256 salt\n    );\n\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\n    uint256 private constant UINT256_MAX = 2 ** 256 - 1;\n\n    address payable public beneficiary;\n    address public buyerFeeSigner;\n\n    /// @notice The address of a transfer proxy for ERC721 and ERC1155 tokens.\n    TransferProxy public transferProxy;\n    /// @notice The address of a transfer proxy for deprecated ERC721 tokens. Does not use safe transfer.\n    TransferProxyForDeprecated public transferProxyForDeprecated;\n    /// @notice The address of a transfer proxy for ERC20 tokens.\n    ERC20TransferProxy public erc20TransferProxy;\n    /// @notice The address of a transfer proxy for ERC20 tokens.\n    ERC20TransferProxyForDeprecated public erc20TransferProxyForDeprecated;\n    /// @notice The address of a transfer proxy for BEP20 tokens.\n    BEP20TransferProxy public bep20TransferProxy;\n    /// @notice The address of a state contract, which counts the amount of selled tokens.\n    ExchangeStateV1 public state;\n    /// @notice The address of a orders holder contract, which can contain unsigned orders.\n    ExchangeOrdersHolderV1 public ordersHolder;\n\n    /// @notice Contract constructor.\n    /// @param _transferProxy - The address of a deployed TransferProxy contract.\n    /// @param _transferProxyForDeprecated - The address of a deployed TransferProxyForDeprecated contract.\n    /// @param _erc20TransferProxy - The address of a deployed ERC20TransferProxy contract.\n    /// @param _state - The address of a deployed ExchangeStateV1 contract.\n    /// @param _ordersHolder - The address of a deployed ExchangeOrdersHolderV1 contract.\n    /// @param _beneficiary - The address wich will receive collected fees.\n    /// @param _buyerFeeSigner - The address to sign buyer\u0027s fees for orders.\n    constructor(\n        TransferProxy _transferProxy,\n        TransferProxyForDeprecated _transferProxyForDeprecated,\n        ERC20TransferProxy _erc20TransferProxy,\n        ERC20TransferProxyForDeprecated _erc20TransferProxyForDeprecated,\n        BEP20TransferProxy _bep20TransferProxy,\n        ExchangeStateV1 _state,\n        ExchangeOrdersHolderV1 _ordersHolder,\n        address payable _beneficiary,\n        address _buyerFeeSigner\n    )  {\n        transferProxy = _transferProxy;\n        transferProxyForDeprecated = _transferProxyForDeprecated;\n        erc20TransferProxy = _erc20TransferProxy;\n        erc20TransferProxyForDeprecated = _erc20TransferProxyForDeprecated;\n        bep20TransferProxy = _bep20TransferProxy;\n        state = _state;\n        ordersHolder = _ordersHolder;\n        beneficiary = _beneficiary;\n        buyerFeeSigner = _buyerFeeSigner;\n    }\n\n    /// @notice This function is called by contract owner and sets fee receiver address.\n    /// @param newBeneficiary - new address, who where all the fees will be transfered\n    function setBeneficiary(address payable newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n    }\n\n    /// @notice This function is called by contract owner and sets fee signer address.\n    /// @param newBuyerFeeSigner - new address, which will sign buyer\u0027s fees for orders\n    function setBuyerFeeSigner(address newBuyerFeeSigner) external onlyOwner {\n        buyerFeeSigner = newBuyerFeeSigner;\n    }\n\n\n    /// @notice This function is called by contract owner and sets fee receiver address.\n    function setTransferProxy(TransferProxy _transferProxy) external onlyOwner {\n        transferProxy = _transferProxy;\n    }\n    \n    /// @notice This function is called by contract owner and sets fee receiver address.\n    function setErc20TransferProxy(ERC20TransferProxy _erc20TransferProxy) external onlyOwner {\n        erc20TransferProxy = _erc20TransferProxy;\n    }\n    \n    /// @notice This function is called by contract owner and sets fee receiver address.\n    function setTransferProxyForDeprecated(TransferProxyForDeprecated _transferProxyForDeprecated) external onlyOwner {\n        transferProxyForDeprecated = _transferProxyForDeprecated;\n    }\n    \n    /// @notice This function is called by contract owner and sets fee receiver address.\n    function setErc20TransferProxyForDeprecated(ERC20TransferProxyForDeprecated _erc20TransferProxyForDeprecated) external onlyOwner {\n        erc20TransferProxyForDeprecated = _erc20TransferProxyForDeprecated;\n    }\n    \n    /// @notice This function is called by contract owner and sets fee receiver address.\n    function setBep20TransferProxy(BEP20TransferProxy _bep20TransferProxy) external onlyOwner {\n        bep20TransferProxy = _bep20TransferProxy;\n    }\n\n    /// @notice This function is called to execute the exchange.\n    /// @notice ERC20, ERC721 or ERC1155 tokens from buyer\u0027s or seller\u0027s side must be approved for this contract before calling this function.\n    /// @notice To pay with ETH, transaction must send ether within the calling transaction.\n    /// @notice Buyer\u0027s payment value is calculated as `order.buying * amount / order.selling + buyerFee%`.\n    /// @dev Emits Buy event.\n    /// @param order - Order struct (see ExchangeDomainV1).\n    /// @param sig - Signed order message. To generate the message call `prepareMessage` function.\n    ///        Message must be prefixed with: `\"\\x19Ethereum Signed Message:\\n\" + message.length`.\n    ///        For example, web3.accounts.sign will automatically prefix the message.\n    ///        Also, the signature might be all zeroes, if specified order record was added to the ordersHolder.\n    /// @param buyerFee - Amount for buyer\u0027s fee. Represented as percents * 100 (100% =\u003e 10000. 1% =\u003e 100).\n    /// @param buyerFeeSig - Signed order + buyerFee message. To generate the message call prepareBuyerFeeMessage function.\n    ///        Message must be prefixed with: `\"\\x19Ethereum Signed Message:\\n\" + message.length`.\n    ///        For example, web3.accounts.sign will automatically prefix the message.\n    /// @param amount - Amount of tokens to buy.\n    /// @param buyer - The buyer\u0027s address.\n    function exchange(\n        Order calldata order,\n        Sig calldata sig,\n        uint buyerFee,\n        Sig calldata buyerFeeSig,\n        uint amount,\n        address buyer\n    ) payable external {\n        validateOrderSig(order, sig);\n        validateBuyerFeeSig(order, buyerFee, buyerFeeSig);\n        uint paying = order.buying.mul(amount).div(order.selling);\n        verifyOpenAndModifyOrderState(order.key, order.selling, amount);\n        require(order.key.sellAsset.assetType != AssetType.ETH, \"ETH is not supported on sell side\");\n        if (order.key.buyAsset.assetType == AssetType.ETH) {\n            uint256 _value; uint256 _buyerFeeValue;\n            (_value, _buyerFeeValue) = validateEthTransfer(paying, buyerFee);\n            payable(msg.sender).sendValue(msg.value - (_value + _buyerFeeValue));\n        }\n        FeeSide feeSide = getFeeSide(order.key.sellAsset.assetType, order.key.buyAsset.assetType);\n        \n        if (buyer == address(0x0)) {\n            buyer = msg.sender;\n        }\n        transferWithFeesPossibility(order.key.sellAsset, amount, payable(order.key.owner), payable(buyer), feeSide == FeeSide.SELL, buyerFee, order.sellerFee, order.key.buyAsset);\n        transferWithFeesPossibility(order.key.buyAsset, paying, payable(buyer), payable(order.key.owner), feeSide == FeeSide.BUY, order.sellerFee, buyerFee, order.key.sellAsset);\n        emitBuy(order, amount, buyer);\n    }\n\n    function validateEthTransfer(uint value, uint buyerFee) internal view returns(uint256, uint256){\n        uint256 buyerFeeValue = value.bp(buyerFee);\n        require(msg.value \u003e= value + buyerFeeValue, \"msg.value is incorrect\");\n        return (value, buyerFeeValue);\n    }\n\n    /// @notice Cancel the token exchange order. Can be called only by the order owner.\n    ///         The function makes all exchnage calls for this order revert with error.\n    /// @param key - The OrderKey struct of the order.\n    function cancel(OrderKey calldata key) external {\n        require(key.owner == msg.sender, \"not an owner\");\n        state.setCompleted(key, UINT256_MAX);\n        emit Cancel(key.sellAsset.token, key.sellAsset.tokenId, msg.sender, key.buyAsset.token, key.buyAsset.tokenId, key.salt);\n    }\n\n    function validateOrderSig(\n        Order memory order,\n        Sig memory sig\n    ) internal view {\n        if (sig.v == 0 \u0026\u0026 sig.r == bytes32(0x0) \u0026\u0026 sig.s == bytes32(0x0)) {\n            require(ordersHolder.exists(order), \"incorrect signature\");\n        } else {\n            require(prepareMessage(order).recover(sig.v, sig.r, sig.s) == order.key.owner, \"incorrect signature\");\n        }\n    }\n\n    function validateBuyerFeeSig(\n        Order memory order,\n        uint buyerFee,\n        Sig memory sig\n    ) internal view {\n        require(prepareBuyerFeeMessage(order, buyerFee).recover(sig.v, sig.r, sig.s) == buyerFeeSigner, \"incorrect buyer fee signature\");\n    }\n\n    /// @notice This function generates fee message to sign for exchange call.\n    /// @param order - Order struct.\n    /// @param fee - Fee amount.\n    /// @return Encoded (order, fee) message, wich should be signed by the buyerFeeSigner. Does not contain standard prefix.\n    function prepareBuyerFeeMessage(Order memory order, uint fee) private pure returns (string memory) {\n        return keccak256(abi.encode(order, fee)).toString();\n    }\n\n    /// @notice This function generates order message to sign for exchange call.\n    /// @param order - Order struct.\n    /// @return Encoded order message, wich should be signed by the token owner. Does not contain standard prefix.\n    function prepareMessage(Order memory order) private pure returns (string memory) {\n        return keccak256(abi.encode(order)).toString();\n    }\n\n    function transferWithFeesPossibility(Asset memory firstType, uint value, address payable from, address payable to, bool hasFee, uint256 sellerFee, uint256 buyerFee, Asset memory secondType) internal {\n        if (!hasFee) {\n            transfer(firstType, value, from, to);\n        } else {\n            transferWithFees(firstType, value, from, to, sellerFee, buyerFee, secondType);\n        }\n    }\n\n    function transfer(Asset memory asset, uint value, address from, address payable to) internal {\n        if (asset.assetType == AssetType.ETH) {\n            address payable toPayable = to;\n            toPayable.sendValue(value);\n        } else if (asset.assetType == AssetType.ERC20) {\n            require(asset.tokenId == 0, \"tokenId should be 0\");\n            erc20TransferProxy.erc20safeTransferFrom(IERC20(asset.token), from, to, value);\n        } else if (asset.assetType == AssetType.ERC20Deprecated) {\n            require(asset.tokenId == 0, \"tokenId should be 0\");\n            erc20TransferProxyForDeprecated.erc20TransferFrom(DIERC20(asset.token), from, to, value);\n        }\n        else if (asset.assetType == AssetType.BEP20) {\n            require(asset.tokenId == 0, \"tokenId should be 0\");\n            bep20TransferProxy.bep20TransferFrom(IBEP20(asset.token), from, to, value);\n        }\n        else if (asset.assetType == AssetType.ERC721) {\n            require(value == 1, \"value should be 1 for ERC-721\");\n            transferProxy.erc721safeTransferFrom(IERC721(asset.token), from, to, asset.tokenId);\n        } else if (asset.assetType == AssetType.ERC721Deprecated) {\n            require(value == 1, \"value should be 1 for ERC-721\");\n            transferProxyForDeprecated.erc721TransferFrom(IERC721(asset.token), from, to, asset.tokenId);\n        } else {\n            transferProxy.erc1155safeTransferFrom(IERC1155(asset.token), from, to, asset.tokenId, value, \"\");\n        }\n    }\n\n    function transferWithFees(Asset memory firstType, uint value, address from, address payable to, uint256 sellerFee, uint256 buyerFee, Asset memory secondType) internal {\n        uint restValue = transferFeeToBeneficiary(firstType, from, value, sellerFee, buyerFee);\n        if (\n            secondType.assetType == AssetType.ERC1155 \u0026\u0026 IERC1155(secondType.token).supportsInterface(_INTERFACE_ID_FEES) ||\n            (secondType.assetType == AssetType.ERC721 || secondType.assetType == AssetType.ERC721Deprecated) \u0026\u0026 IERC721(secondType.token).supportsInterface(_INTERFACE_ID_FEES)\n        ) {\n            HasSecondarySaleFees withFees = HasSecondarySaleFees(secondType.token);\n            address payable[] memory recipients = withFees.getFeeRecipients(secondType.tokenId);\n            uint[] memory fees = withFees.getFeeBps(secondType.tokenId);\n            require(fees.length == recipients.length);\n            for (uint256 i = 0; i \u003c fees.length; i++) {\n                (uint newRestValue, uint current) = subFeeInBp(restValue, value, fees[i]);\n                restValue = newRestValue;\n                transfer(firstType, current, from, recipients[i]);\n            }\n        }\n        address payable toPayable = to;\n        transfer(firstType, restValue, from, toPayable);\n    }\n\n    function transferFeeToBeneficiary(Asset memory asset, address from, uint total, uint sellerFee, uint buyerFee) internal returns (uint) {\n        (uint restValue, uint sellerFeeValue) = subFeeInBp(total, total, sellerFee);\n        uint buyerFeeValue = total.bp(buyerFee);\n        uint beneficiaryFee = buyerFeeValue.add(sellerFeeValue);\n        if (beneficiaryFee \u003e 0) {\n            transfer(asset, beneficiaryFee, from, beneficiary);\n        }\n        return restValue;\n    }\n\n    function emitBuy(Order memory order, uint amount, address buyer) internal {\n        emit Buy(order.key.sellAsset.token, order.key.sellAsset.tokenId, order.selling,\n            order.key.owner,\n            order.key.buyAsset.token, order.key.buyAsset.tokenId, order.buying,\n            buyer,\n            amount,\n            order.key.salt\n        );\n    }\n\n    function subFeeInBp(uint value, uint total, uint feeInBp) internal pure returns (uint newValue, uint realFee) {\n        return subFee(value, total.bp(feeInBp));\n    }\n\n    function subFee(uint value, uint fee) internal pure returns (uint newValue, uint realFee) {\n        if (value \u003e fee) {\n            newValue = value - fee;\n            realFee = fee;\n        } else {\n            newValue = 0;\n            realFee = value;\n        }\n    }\n\n    function verifyOpenAndModifyOrderState(OrderKey memory key, uint selling, uint amount) internal {\n        uint completed = state.getCompleted(key);\n        uint newCompleted = completed.add(amount);\n        require(newCompleted \u003c= selling, \"not enough stock of order for buying\");\n        state.setCompleted(key, newCompleted);\n    }\n\n    function getFeeSide(AssetType sellType, AssetType buyType) internal pure returns (FeeSide) {\n        if ((sellType == AssetType.ERC721 || sellType == AssetType.ERC721Deprecated) \u0026\u0026\n            (buyType == AssetType.ERC721 || buyType == AssetType.ERC721Deprecated)) {\n            return FeeSide.NONE;\n        }\n        if (uint(sellType) \u003e uint(buyType)) {\n            return FeeSide.BUY;\n        }\n        return FeeSide.SELL;\n    }\n}"},"HasTokenURI.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./libs.sol\";\n\ncontract HasTokenURI {\n    using StringLibrary for string;\n\n    //Token URI prefix\n    string public tokenURIPrefix;\n\n    // Optional mapping for token URIs\n    mapping(uint256 =\u003e string) private _tokenURIs;\n\n    constructor(string memory _tokenURIPrefix) {\n        tokenURIPrefix = _tokenURIPrefix;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID.\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\n        return tokenURIPrefix.append(_tokenURIs[tokenId]);\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) virtual internal {\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to set the token URI prefix.\n     * @param _tokenURIPrefix string URI prefix to assign\n     */\n    function _setTokenURIPrefix(string memory _tokenURIPrefix) internal {\n        tokenURIPrefix = _tokenURIPrefix;\n    }\n\n    function _clearTokenURI(uint256 tokenId) internal {\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface IBEP20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view returns (uint8);\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view returns (address);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address _owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender\u0027s allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller\u0027s\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./ERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}"},"InoContract.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./libs.sol\";\nimport \"./IBEP20.sol\";\nimport \"./MultiCollection.sol\";\nimport \"./ReentrancyGuard.sol\";\n\n\ncontract InoCrowdFunding is Ownable, AdminRole, ReentrancyGuard{\n    using SafeMath for uint;\n    using UintLibrary for uint;\n    using SafeBEP20 for IBEP20;\n    \n    // @notice The struct manages Ino deadlines\n    // @param start - Start time of Ino funding in UNIX format \n    // @param end - End time of Ino funding in UNIX format \n    struct Deadlines{\n        uint start;\n        uint end;\n    }\n\n    // @notice The Main Ino funding\u0027s struct\n    // @param tokenId - Token id to minting\n    // @param creator - The address of the creator of the new token\n    // @param fixContribution - The fixed amount of contributions\n    // @param fundingFee -  fundingFee - Percent of fee that will gold in this contract\n    // For example - fundingFee = 10. Contributions amount - 1000 \n    // Will remain in the contract -1000*(10/100)\n    // @param deadlines - Filled Deadline struct\n    // @param completing - Filled Completing struct\n    struct Funding{\n        uint tokenId;\n        address payable creator;\n        uint fixContribution;\n        uint fundingFee;\n        uint maxCopies;\n        uint remains;\n        uint royalty;\n        Deadlines deadlines;\n    }\n\n    \n    // All ino fudings by their id\n    mapping (uint =\u003e Funding) public fundings;\n    // Is funding by fundId opened\n    mapping (uint =\u003e bool) public isOpen;\n    // Array of contributions by ino funding id\n    mapping (uint =\u003e address[]) contributors;\n    // fundid =\u003e address =\u003e number\n    mapping (uint =\u003e mapping(address =\u003e InoMultiCollection.Contribution)) contributions;\n\n\n    address payable public beneficiary;\n    \n    IBEP20 OriInterface;\n    InoMultiCollection InoInterface;\n    \n    // @param _interfaceOri - address of the BEP20 token (ORI main contract)\n    // @param _interfaceIno - address of the InoMultiCollection contract (NFT)\n    constructor(IBEP20 _interfaceOri, InoMultiCollection _interfaceIno, address _admin, address payable _beneficiary) {\n        OriInterface = _interfaceOri;\n        InoInterface = _interfaceIno;\n        \n        _addAdmin(msg.sender);\n        _addAdmin(_admin);\n        beneficiary = _beneficiary;\n    }\n    \n    modifier isOpened(uint256 _fundId){\n        require(isOpen[_fundId], \"This funding is closed\");\n        _;\n    }\n    \n    event InoCreated(uint256 indexed tokenId, bool isOpen, address creator, uint fee, uint royalty, uint copies, uint startDate, uint endDate);\n    event InoContributed(uint256 inoId, uint256 indexed tokenId, uint256 contributeAmount, address buyer, address creator, uint numberCopies);\n    event InoClosed(uint256 inoId, uint256 indexed tokenId, uint256 contributeAmount);\n    event InoCompleted(uint256 inoId, uint256 indexed tokenId, uint256 awardAmount);\n    \n    // @notice Checks the existence of the token by its Id\n    // @param _id - token id\n    // @return True if token aldready exists\n    function isMinted(uint _id) view internal returns(bool) {\n        if(InoInterface.creators(_id) == address(0)){return false;}\n        return true;\n    }\n\n    // @notice Creates Ino funding\n    // @param _fundId - Id of new token to minting. The funding will be created with this Id\n    // @param _creator - Address of the new token creator\n    // @param _fixContribution - Fixed contribution amount\n    // @param _startTime - Time of start in UNIX format\n    // @param _endTime - Time of end in UNIX format\n    // @param _fee - Amount of system fee in percent format. 1% = 100\n    // @param _copies - The allowed number of tokens for minting\n    // @param _royalty - fee dividing between all contributors. 1% = 100\n    function createIno(uint _fundId, address payable _creator, uint _fixContribution,\n        uint _startTime, uint _endTime, uint _fee, uint _copies, uint _royalty) public onlyAdmin nonReentrant{\n        require(!isMinted(_fundId), \"Token is already minted\");\n        require(!isOpen[_fundId], \"Ino is opened\");\n        require(fundings[_fundId].creator == address(0), \"Ino is already created\");\n        require(_creator != address(0), \"Creator addres must be non zero\");\n        require(_fixContribution \u003e 0, \"Amount of fixContribution must be more 0\");\n        require(_fee \u003c= 10000, \"Amount of fee must be less\");\n        require(_copies \u003c= 1000 \u0026\u0026 _copies \u003e 0, \"Number of copies must be non-zero and less than 1000\");\n        require(_startTime \u003c _endTime, \"End time earlier than start\");\n        require(_royalty \u003c= 10000, \"Amount of royalty must be less\");\n        \n        fundings[_fundId] = Funding(_fundId, _creator, _fixContribution, _fee, _copies, _copies, _royalty, Deadlines(_startTime, _endTime));\n        isOpen[_fundId] = true;\n        \n        emit InoCreated(\n            fundings[_fundId].tokenId, \n            isOpen[_fundId], \n            fundings[_fundId].creator, \n            fundings[_fundId].fundingFee, \n            fundings[_fundId].royalty, \n            fundings[_fundId].maxCopies, \n            _startTime, \n            _endTime);\n    }\n    \n    // @notice Returns Ino funding by its id\n    // @param _id - Ino funding id\n    function getFunding(uint _id) view public returns(Funding memory) {\n        return fundings[_id];\n    }\n    \n    // @notice Returns list of the contributions by Ino funding id\n    // @param _id - Ino funding id\n    function getContributors(uint _id) view public returns(address[] memory){\n        return contributors[_id];\n    }\n\n    // @notice Returns amount of contributions by Ino funding id and address\n    // @param _id - Ino funding id\n    function getContributionsAmount(uint _id, address contributor) view public returns(uint){\n        return getCopiesNumber(_id, contributor).mul(fundings[_id].fixContribution);\n    }\n\n    // @notice Returns number of copies by Ino funding id and address\n    // @param _id - Ino funding id\n    function getCopiesNumber(uint _id, address contributor) view public returns(uint){\n        return contributions[_id][contributor].copies;\n    }\n    \n    // @notice Adds new contribution to Ino by its id\n    // Before calling you need to approve some token\u0027s amount to this contract\n    // Some amount will be holded at this contract\n    // @param _fundId - Ino funding id\n    // @param amount - amount of contributing ino\n    function contribute(uint _fundId, uint amount) external isOpened(_fundId) nonReentrant{\n        require(amount \u003e 0, \"Amount must be non-zero\");\n        require(fundings[_fundId].deadlines.start \u003c= block.timestamp, \"Too early\");\n        require(fundings[_fundId].deadlines.end \u003e= block.timestamp, \"Too late\");\n        require(fundings[_fundId].remains \u003e= amount, \"There are no more copies\");\n        require(msg.sender != address(0), \"zero msg.sender\");\n        require(OriInterface.allowance(msg.sender, address(this)) \u003e= amount.mul(fundings[_fundId].fixContribution), \"Not enough approved tokens\");\n        \n        OriInterface.safeTransferFrom(msg.sender, address(this), amount.mul(fundings[_fundId].fixContribution));\n\n        fundings[_fundId].remains = fundings[_fundId].remains.sub(amount);\n        \n        if (contributions[_fundId][msg.sender].copies == 0)\n            contributors[_fundId].push(msg.sender);\n        contributions[_fundId][msg.sender].copies = contributions[_fundId][msg.sender].copies.add(amount);\n        \n\n        uint holdedTokensAmount = fundings[_fundId].fixContribution.mul(amount).bp(fundings[_fundId].fundingFee);\n        OriInterface.safeTransfer(beneficiary, holdedTokensAmount);\n\n        uint awardAmount = fundings[_fundId].fixContribution.mul(amount).sub(holdedTokensAmount);\n        emit InoContributed(_fundId, fundings[_fundId].tokenId, awardAmount, msg.sender, fundings[_fundId].creator, amount);\n    }\n    \n    // @notice Only for owner. Closes Ino by its id\n    // All contributions will be refunded to contributors\n    // But some amount already holded at this contract\n    // Ino will be closed if all contributors have recieved their contributions\n    // @param _fundId - Ino funding id \n    function closeIno(uint _fundId) external onlyAdmin isOpened(_fundId) nonReentrant{\n        uint refundAmount = fundings[_fundId].fixContribution.sub(fundings[_fundId].fixContribution.bp(fundings[_fundId].fundingFee));\n        \n        for(uint i = 0; i \u003c contributors[_fundId].length; i++){\n            address contributor = contributors[_fundId][i];\n            uint256 contributorRefund = refundAmount.mul(contributions[_fundId][contributor].copies);\n            OriInterface.safeTransfer(contributor, contributorRefund);\n        }\n\n        isOpen[_fundId] = false;\n        emit InoClosed(_fundId, fundings[_fundId].tokenId, refundAmount);\n    } \n\n    // @notice Only for owner. Completes and closes Ino by its id\n    // Will complete minting a new NFT\n    // Contributions will be transfered to Ino creator address\n    // But some amount already holded at this contract\n    // @param _fundId - Ino funding id \n    // @param _uri - Uri for minting\n    function completeIno(uint _fundId, string calldata _uri) external onlyAdmin isOpened(_fundId) nonReentrant{\n        (uint awardAmount,) = getFundingAmount(_fundId);\n        OriInterface.safeTransfer(fundings[_fundId].creator, awardAmount);\n\n        InoMultiCollection.Contribution[] memory _contributions = parseContributions(_fundId);\n        \n        InoInterface.mintIno(fundings[_fundId].tokenId, fundings[_fundId].creator, _contributions, fundings[_fundId].royalty, _uri);\n        isOpen[_fundId] = false;\n\n        emit InoCompleted(_fundId, fundings[_fundId].tokenId, awardAmount);\n    } \n\n    function getFundingAmount(uint _fundId) public view returns(uint256 contributedAmount, uint256 holdedByContract){\n        uint awardAmount = fundings[_fundId].fixContribution.mul(fundings[_fundId].maxCopies.sub(fundings[_fundId].remains));\n        uint holdedAmount =  awardAmount.bp(fundings[_fundId].fundingFee);\n        awardAmount = awardAmount.sub(holdedAmount);\n        return (awardAmount, holdedAmount);\n    } \n\n    function parseContributions(uint _fundId) public view returns(InoMultiCollection.Contribution[] memory) {\n        InoMultiCollection.Contribution[] memory _contributions = new InoMultiCollection.Contribution[](contributors[_fundId].length);\n\n        for (uint i = 0; i \u003c contributors[_fundId].length; i++){\n            address contributor = contributors[_fundId][i];\n            uint copies = contributions[_fundId][contributor].copies;\n            _contributions[i] = InoMultiCollection.Contribution(contributor, copies);\n        }\n\n        return _contributions;\n    }\n    \n    // @notice Adds the Admin Role to new address\n    function addAdmin(address admin) public onlyOwner{\n        _addAdmin(admin);\n    }\n    \n    // @notice Removes the Admin Role from the address \n    function removeAdmin(address admin) public onlyOwner{\n        _removeAdmin(admin);\n    }\n\n    function setBeneficiary(address payable _beneficiary) public onlyOwner {\n        beneficiary = _beneficiary;\n    }\n}\n"},"libs.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"\\\"SafeMath: addition overflow\\\"\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"\\\"SafeMath: multiplication overflow\\\"\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"\\\"SafeMath: division by zero\\\"\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"\\\"SafeMath: modulo by zero\\\"\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\nlibrary UintLibrary {\n    using SafeMath for uint;\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function bp(uint value, uint bpValue) internal pure returns (uint) {\n        return value.mul(bpValue).div(10000);\n    }\n}\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n    \n    function toBytes32(string memory source) public pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n\nlibrary StringLibrary {\n    using UintLibrary for uint256;\n\n    function append(string memory _a, string memory _b) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory bab = new bytes(_ba.length + _bb.length);\n        uint k = 0;\n        for (uint i = 0; i \u003c _ba.length; i++) bab[k++] = _ba[i];\n        for (uint i = 0; i \u003c _bb.length; i++) bab[k++] = _bb[i];\n        return string(bab);\n    }\n\n    function append(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory bbb = new bytes(_ba.length + _bb.length + _bc.length);\n        uint k = 0;\n        for (uint i = 0; i \u003c _ba.length; i++) bbb[k++] = _ba[i];\n        for (uint i = 0; i \u003c _bb.length; i++) bbb[k++] = _bb[i];\n        for (uint i = 0; i \u003c _bc.length; i++) bbb[k++] = _bc[i];\n        return string(bbb);\n    }\n\n    function recover(string memory message, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        bytes memory msgBytes = bytes(message);\n        bytes memory fullMessage = concat(\n            bytes(\"\\x19Ethereum Signed Message:\\n\"),\n            bytes(msgBytes.length.toString()),\n            msgBytes,\n            new bytes(0), new bytes(0), new bytes(0), new bytes(0)\n        );\n        return ecrecover(keccak256(fullMessage), v, r, s);\n    }\n\n    function concat(bytes memory _ba, bytes memory _bb, bytes memory _bc, bytes memory _bd, bytes memory _be, bytes memory _bf, bytes memory _bg) internal pure returns (bytes memory) {\n        bytes memory resultBytes = new bytes(_ba.length + _bb.length + _bc.length + _bd.length + _be.length + _bf.length + _bg.length);\n        uint k = 0;\n        for (uint i = 0; i \u003c _ba.length; i++) resultBytes[k++] = _ba[i];\n        for (uint i = 0; i \u003c _bb.length; i++) resultBytes[k++] = _bb[i];\n        for (uint i = 0; i \u003c _bc.length; i++) resultBytes[k++] = _bc[i];\n        for (uint i = 0; i \u003c _bd.length; i++) resultBytes[k++] = _bd[i];\n        for (uint i = 0; i \u003c _be.length; i++) resultBytes[k++] = _be[i];\n        for (uint i = 0; i \u003c _bf.length; i++) resultBytes[k++] = _bf[i];\n        for (uint i = 0; i \u003c _bg.length; i++) resultBytes[k++] = _bg[i];\n        return resultBytes;\n    }\n}\n\n\n\nlibrary BytesLibrary {\n    function toString(bytes32 value) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(64);\n        for (uint256 i = 0; i \u003c 32; i++) {\n            str[i*2] = alphabet[uint8(value[i] \u003e\u003e 4)];\n            str[1+i*2] = alphabet[uint8(value[i] \u0026 0x0f)];\n        }\n        return string(str);\n    }\n}\n\nlibrary AddressLibrary {\n    function toString(address _addr) internal pure returns (string memory) {\n        uint256 i = uint256(uint160(_addr));\n        bytes32 value = bytes32(i);\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = \u00270\u0027;\n        str[1] = \u0027x\u0027;\n        for (uint256 ind = 0; ind \u003c 20; ind++) {\n            str[2+ind*2] = alphabet[uint8(value[ind + 12] \u003e\u003e 4)];\n            str[3+ind*2] = alphabet[uint8(value[ind + 12] \u0026 0x0f)];\n        }\n        return string(str);\n    }\n}\n\nlibrary ECDSA {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v \u003c 27) {\n            v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 \u0026\u0026 v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * toEthSignedMessageHash\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n     * and hash the result\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\nimport \"./IBEP20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeBEP20 {\n    using Address for address;\n\n    function safeTransfer(\n        IBEP20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IBEP20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"MultiCollection.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC1155.sol\";\nimport \"./libs.sol\";\n\n\n/// @title MultiToken\n/// @notice ERC1155 token contract with the support of secondary fees.\ncontract MultiCollection is Ownable, SignerRole, ERC1155Base {\n    using BytesLibrary for bytes32;\n    using SafeMath for uint256;\n    using StringLibrary for string;\n    /// @notice Tokens name;\n    string public name;\n    /// @notice Tokens symbol.\n    string public symbol;\n\n    /// @notice The contract constructor.\n    /// @param _name - The value for the `name`.\n    /// @param _symbol - The value for the `symbol`.\n    /// @param contractURI - The URI with contract metadata.\n    ///        The metadata should be a JSON object with fields: `id, name, description, image, external_link`.\n    ///        If the URI containts `{address}` template in its body, then the template must be substituted with the contract address.\n    /// @param tokenURIPrefix - The URI prefix for all the tokens. Usually set to ipfs gateway.\n    /// @param signer - The address of the initial signer.\n    constructor(string memory _name, string memory _symbol, string memory contractURI, string memory tokenURIPrefix, address signer) ERC1155Base(contractURI, tokenURIPrefix) {\n        name = _name;\n        symbol = _symbol;\n\n        _addSigner(signer);\n        _registerInterface(bytes4(keccak256(\u0027MINT_WITH_ADDRESS\u0027)));\n    }\n\n    /// @notice This function can be called by the contract owner and it adds an address as a new signer.\n    ///         The signer will authorize token minting by signing token ids.\n    /// @param account - The address of a new signer.\n    function addSigner(address account) public override onlyOwner {\n        _addSigner(account);\n    }\n\n    /// @notice This function can be called by the contract owner and it removes an address from signers pool.\n    /// @param account - The address of a signer to remove.\n    function removeSigner(address account) public onlyOwner {\n        _removeSigner(account);\n    }\n\n    /// @notice The function for token minting. It creates a new token.\n    ///         Must contain the signature of the format: `sha3(tokenContract.address.toLowerCase() + tokenId)`.\n    ///         Where `tokenContract.address` is the address of the contract and tokenId is the id in uint256 hex format.\n    ///         0 as uint256 must look like this: `0000000000000000000000000000000000000000000000000000000000000000`.\n    ///         The message **must not contain** the standard prefix.\n    /// @param id - The id of a new token (`tokenId`).\n    /// @param v - v parameter of the ECDSA signature.\n    /// @param r - r parameter of the ECDSA signature.\n    /// @param s - s parameter of the ECDSA signature.\n    /// @param fees - An array of the secondary fees for this token.\n    /// @param supply - The supply amount for the token.\n    /// @param uri - The URI suffix for the token. The suffix with `tokenURIPrefix` usually complements ipfs link to metadata object.\n    ///        The URI must link to JSON object with various fields: `name, description, image, external_url, attributes`.\n    ///        Can also contain another various fields.\n    function mint(uint256 id, uint8 v, bytes32 r, bytes32 s, Fee[] memory fees, uint256 supply, string memory uri) public {\n        require(isSigner(prepareMessage(id, this).recover(v, r, s)), \"signer should sign tokenId\");\n        _mint(id, fees, supply, uri);\n    }\n    \n    function prepareMessage(uint256 _id, MultiCollection _contAddr) private pure returns (string memory) {\n        return keccak256(abi.encode(_id, address(_contAddr))).toString();\n    }\n}\n\n/**\n * @title MultiUserToken\n * @dev Only owner can mint tokens.\n */\ncontract MultiUserCollection is MultiCollection {\n    uint public maxTokenId;\n    /// @notice Token minting event.\n    event CreateERC1155_v1(address indexed creator, string name, string symbol);\n\n    /// @notice The contract constructor.\n    /// @param name - The value for the `name`.\n    /// @param symbol - The value for the `symbol`.\n    /// @param contractURI - The URI with contract metadata.\n    ///        The metadata should be a JSON object with fields: `id, name, description, image, external_link`.\n    ///        If the URI containts `{address}` template in its body, then the template must be substituted with the contract address.\n    /// @param tokenURIPrefix - The URI prefix for all the tokens. Usually set to ipfs gateway.\n    constructor(string memory name, string memory symbol, string memory contractURI, string memory tokenURIPrefix) MultiCollection(name, symbol, contractURI, tokenURIPrefix, address(this)) {\n        emit CreateERC1155_v1(msg.sender, name, symbol);\n    }\n\n    /// @notice The function for token minting. It creates a new token. Can be called only by the contract owner.\n    ///         Must contain the signature of the format: `sha3(tokenContract.address.toLowerCase() + tokenId)`.\n    ///         Where `tokenContract.address` is the address of the contract and tokenId is the id in uint256 hex format.\n    ///         0 as uint256 must look like this: `0000000000000000000000000000000000000000000000000000000000000000`.\n    ///         The message **must not contain** the standard prefix.\n    /// @param id - The id of a new token (`tokenId`).\n    /// @param fees - An array of the secondary fees for this token.\n    /// @param supply - The supply amount for the token.\n    /// @param uri - The URI suffix for the token. The suffix with `tokenURIPrefix` usually complements ipfs link to metadata object.\n    ///        The URI must link to JSON object with various fields: `name, description, image, external_url, attributes`.\n    ///        Can also contain another various fields.\n    function mint(uint256 id, Fee[] memory fees, uint256 supply, string memory uri) onlyOwner public {\n        _mint(id, fees, supply, uri);\n        if (id \u003e maxTokenId)\n            maxTokenId = id;\n    }\n}\n\ncontract InoMultiCollection is MultiCollection{\n    using BytesLibrary for bytes32;\n    using SafeMath for uint256;\n    using Address for address;\n    \n    constructor(string memory name, string memory symbol, string memory contractURI, string memory tokenURIPrefix) \n    MultiCollection(name, symbol, contractURI, tokenURIPrefix, address(this) ) {}\n    \n    \n    struct Contribution{\n        address owner;\n        uint copies;\n    }\n\n    // @notice [Only for Contract Owner and Ino Wrapper Contract]\n    // The function performs minting of token Id in the `amount = accounts.length`. \n    // After the minting 1 token will be sent to each of the `accounts`.  \n    // The creator of this token will be `creator`, not `msg.sender`.  \n    // @param _id - The id of a new token (`tokenId`)\n    // @param creator - address of the token creator\n    // @param accounts - addresses of the token Co-owners\n    // @param creatorRoyalty - fee for the token creator\n    // @param uri - the same as in the usual mint()\n    function mintIno(\n        uint256 _id,\n        address payable creator, \n        Contribution[] memory contributions, \n        uint256 royalty,\n        string memory uri) public\n        {\n        require(isSigner(msg.sender), \"Unavailable address of the sender\");\n        Fee[] memory _fees = new Fee[](contributions.length + 1);\n        uint _feeForEachAccount = royalty.div(_fees.length);\n        uint supply = 0;\n        \n        for(uint _contrId = 0; _contrId \u003c _fees.length - 1; _contrId++){\n            supply = supply.add(contributions[_contrId].copies);\n            _fees[_contrId] = Fee(payable(contributions[_contrId].owner), _feeForEachAccount);\n        }\n        _fees[_fees.length-1] = Fee(creator, _feeForEachAccount);\n\n        _mintINO(_id, _fees, supply, uri);\n        \n        safeTransferFromINO(creator, contributions, _id, bytes(\"\"));\n    }\n\n\n    function _mintINO(uint256 id, Fee[] memory fees, uint256 supply, string memory uri) private {\n        _mintFromCreator(id, fees, supply, uri);\n    }\n    \n    function prepareMessage(uint256 _id, InoMultiCollection _contAddr) private pure returns (string memory) {\n        return keccak256(abi.encode(_id, address(_contAddr))).toString();\n    }\n\n    /// @notice Creates a new token type and assings _initialSupply to minter\n    function _mintFromCreator(uint256 _id, Fee[] memory _fees, uint256 _supply, string memory _uri) private {\n        require(creators[_id] == address(0x0), \"Token is already minted\");\n        require(_supply != 0, \"Supply should be positive\");\n        require(bytes(_uri).length \u003e 0, \"uri should be set\");\n\n        address creator = _fees[_fees.length-1].recipient;\n        creators[_id] = creator;\n\n        address[] memory recipients = new address[](_fees.length);\n        uint[] memory bps = new uint[](_fees.length);\n        for (uint i = 0; i \u003c _fees.length; i++) {\n            require(_fees[i].recipient != address(0x0), \"Fee recipient should be present\");\n            fees[_id].push(_fees[i]);\n            recipients[i] = _fees[i].recipient;\n            bps[i] = _fees[i].value;\n        }\n\n        balances[_id][creator] = _supply;\n        _setTokenURI(_id, _uri);\n\n        // Transfer event with mint semantic\n        emit TransferSingle(creator, address(0x0), creator, _id, _supply);\n        emit URI(_uri, _id);\n    }\n\n    \n    // @notice The method for transfering token to array of recipients\n    // @param _from - The address of token creator\n    // @param _recipients - The array of recipient addresses\n    // @param _id - The Id of the token\n    // @param _value - The count of token to transfer. Value will be the same for each of the `recipients`\n    // @param _data - Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    function safeTransferFromINO(address _from, Contribution[] memory contributions, uint256 _id, bytes memory _data) public {\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true \n            || isSigner(msg.sender), \n            \"Need operator approval for 3rd party transfers.\");\n        \n        for(uint i; i \u003c contributions.length; i++) {\n            address _to = contributions[i].owner;\n            uint _value = contributions[i].copies;\n            require(_to != address(0x0), \"_to must be non-zero.\");\n            \n            // SafeMath will throw with insuficient funds _from\n            // or if _id is not valid (balance will be 0)\n            balances[_id][_from] = balances[_id][_from].sub(_value);\n            balances[_id][_to]   = balances[_id][_to].add(_value);\n    \n            // MUST emit event\n            emit TransferSingle(msg.sender, _from, _to, _id, _value);\n    \n            // Now that the balance is updated and the event was emitted,\n            // call onERC1155Received if the destination is a contract.\n            if (_to.isContract()) {\n                _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\n            }\n        }\n    }\n}\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"Roles.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address =\u003e bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account\u0027s access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor ()  {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title SignerRole\n * @dev A signer role contract.\n */\nabstract contract SignerRole is Context {\n    using Roles for Roles.Role;\n\n    event SignerAdded(address indexed account);\n    event SignerRemoved(address indexed account);\n\n    Roles.Role private _signers;\n\n    constructor () {\n        _addSigner(_msgSender());\n    }\n\n    /**\n     * @dev Makes function callable only if sender is a signer.\n     */\n    modifier onlySigner() {\n        require(isSigner(_msgSender()), \"SignerRole: caller does not have the Signer role\");\n        _;\n    }\n\n    /**\n     * @dev Checks if the address is a signer.\n     */\n    function isSigner(address account) public view returns (bool) {\n        return _signers.has(account);\n    }\n\n    /**\n     * @dev Makes the address a signer. Only other signers can add new signers.\n     */\n    function addSigner(address account) public virtual onlySigner {\n        _addSigner(account);\n    }\n\n    /**\n     * @dev Removes the address from signers. Signer can be renounced only by himself.\n     */\n    function renounceSigner() public {\n        _removeSigner(_msgSender());\n    }\n\n    function _addSigner(address account) internal {\n        _signers.add(account);\n        emit SignerAdded(account);\n    }\n\n    function _removeSigner(address account) internal {\n        _signers.remove(account);\n        emit SignerRemoved(account);\n    }\n}\n\n/**\n * @title OperatorRole\n * @dev An operator role contract.\n */\nabstract contract OperatorRole is Context {\n    using Roles for Roles.Role;\n\n    event OperatorAdded(address indexed account);\n    event OperatorRemoved(address indexed account);\n\n    Roles.Role private _operators;\n\n    constructor () {\n\n    }\n\n    /**\n     * @dev Makes function callable only if sender is an operator.\n     */\n    modifier onlyOperator() {\n        require(isOperator(_msgSender()), \"OperatorRole: caller does not have the Operator role\");\n        _;\n    }\n\n    /**\n     * @dev Checks if the address is an operator.\n     */\n    function isOperator(address account) public view returns (bool) {\n        return _operators.has(account);\n    }\n\n    function _addOperator(address account) internal {\n        _operators.add(account);\n        emit OperatorAdded(account);\n    }\n\n    function _removeOperator(address account) internal {\n        _operators.remove(account);\n        emit OperatorRemoved(account);\n    }\n}\n\n/**\n * @title OwnableOperatorRole\n * @dev Allows owner to add and remove operators.\n */\ncontract OwnableOperatorRole is Ownable, OperatorRole {\n    /**\n     * @dev Makes the address an operator. Only owner can call this function.\n     */\n    function addOperator(address account) public onlyOwner {\n        _addOperator(account);\n    }\n\n    /**\n     * @dev Removes the address from operators. Only owner can call this function.\n     */\n    function removeOperator(address account) public onlyOwner {\n        _removeOperator(account);\n    }\n}\n\nabstract contract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender));\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\nabstract contract Pausable is PauserRole {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @return true if the contract is paused, false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n/**\n * @title AdminRole\n * @dev An operator role contract.\n */\nabstract contract AdminRole is Context {\n    using Roles for Roles.Role;\n\n    event AdminAdded(address indexed account);\n    event AdminRemoved(address indexed account);\n\n    Roles.Role private _admins;\n\n    constructor () {\n\n    }\n\n    /**\n     * @dev Makes function callable only if sender is an admin.\n     */\n    modifier onlyAdmin() {\n        require(isAdmin(_msgSender()), \"AdminRole: caller does not have the Admin role\");\n        _;\n    }\n\n    /**\n     * @dev Checks if the address is an admin.\n     */\n    function isAdmin(address account) public view returns (bool) {\n        return _admins.has(account);\n    }\n\n    function _addAdmin(address account) internal {\n        _admins.add(account);\n        emit AdminAdded(account);\n    }\n\n    function _removeAdmin(address account) internal {\n        _admins.remove(account);\n        emit AdminRemoved(account);\n    }\n}\n"},"SingleCollection.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./libs.sol\";\nimport \"./Roles.sol\";\nimport \"./ERC721.sol\";\n\n/**\n * @title MintableOwnableToken\n * @dev anyone can mint token.\n */\ncontract SingleCollection is Ownable, ERC721Base, ERC721Burnable, SignerRole {\n    using BytesLibrary for bytes32;\n    using StringLibrary for string;\n    /// @notice Token minting event.\n    event CreateERC721_v4(address indexed creator, string name, string symbol);\n\n    /// @notice The contract constructor.\n    /// @param name - The value for the `name`.\n    /// @param symbol - The value for the `symbol`.\n    /// @param contractURI - The URI with contract metadata.\n    ///        The metadata should be a JSON object with fields: `id, name, description, image, external_link`.\n    ///        If the URI containts `{address}` template in its body, then the template must be substituted with the contract address.\n    /// @param tokenURIPrefix - The URI prefix for all the tokens. Usually set to ipfs gateway.\n    /// @param signer - The address of the initial signer.\n    constructor (string memory name, string memory symbol, string memory contractURI, string memory tokenURIPrefix, address signer) ERC721Base(name, symbol, contractURI, tokenURIPrefix) {\n        emit CreateERC721_v4(msg.sender, name, symbol);\n        _addSigner(signer);\n        _registerInterface(bytes4(keccak256(\u0027MINT_WITH_ADDRESS\u0027)));\n    }\n\n    /// @notice The function for token minting. It creates a new token.\n    ///         Must contain the signature of the format: `sha3(tokenContract.address.toLowerCase() + tokenId)`.\n    ///         Where `tokenContract.address` is the address of the contract and tokenId is the id in uint256 hex format.\n    ///         0 as uint256 must look like this: `0000000000000000000000000000000000000000000000000000000000000000`.\n    ///         The message **must not contain** the standard prefix.\n    /// @param tokenId - The id of a new token.\n    /// @param v - v parameter of the ECDSA signature.\n    /// @param r - r parameter of the ECDSA signature.\n    /// @param s - s parameter of the ECDSA signature.\n    /// @param _fees - An array of the secondary fees for this token.\n    /// @param tokenURI - The suffix with `tokenURIPrefix` usually complements ipfs link to metadata object.\n    ///        The URI must link to JSON object with various fields: `name, description, image, external_url, attributes`.\n    ///        Can also contain another various fields.\n    function mint(uint256 tokenId, uint8 v, bytes32 r, bytes32 s, Fee[] memory _fees, string memory tokenURI) public  {\n        require(isSigner(prepareMessage(tokenId, this).recover(v, r, s)), \"signer should sign tokenId\");\n        _mint(msg.sender, tokenId, _fees);\n        _setTokenURI(tokenId, tokenURI);\n    }\n    \n    function prepareMessage(uint256 _id, SingleCollection _contAddr) private pure returns (string memory) {\n        return keccak256(abi.encode(_id, address(_contAddr))).toString();\n    }\n\n    /// @notice This function can be called by the contract owner and it adds an address as a new signer.\n    ///         The signer will authorize token minting by signing token ids.\n    /// @param account - The address of a new signer.\n    function addSigner(address account) public override onlyOwner {\n        _addSigner(account);\n    }\n\n    /// @notice This function can be called by the contract owner and it removes an address from signers pool.\n    /// @param account - The address of a signer to remove.\n    function removeSigner(address account) public onlyOwner {\n        _removeSigner(account);\n    }\n\n\n    /// @notice Sets the URI prefix for all tokens.\n    function setTokenURIPrefix(string memory tokenURIPrefix) public onlyOwner {\n        _setTokenURIPrefix(tokenURIPrefix);\n    }\n\n\n    /// @notice Sets the URI for the contract metadata.\n    function setContractURI(string memory contractURI) public onlyOwner {\n        _setContractURI(contractURI);\n    }\n}\n\n/**\n * @title MintableUserToken\n * @dev Only owner can mint tokens.\n */\ncontract SingleUserCollection is SingleCollection {\n    uint public maxTokenId;\n    /// @notice The contract constructor.\n    /// @param name - The value for the `name`.\n    /// @param symbol - The value for the `symbol`.\n    /// @param contractURI - The URI with contract metadata.\n    ///        The metadata should be a JSON object with fields: `id, name, description, image, external_link`.\n    ///        If the URI containts `{address}` template in its body, then the template must be substituted with the contract address.\n    /// @param tokenURIPrefix - The URI prefix for all the tokens. Usually set to ipfs gateway.\n\n    constructor(string memory name, string memory symbol, string memory contractURI, string memory tokenURIPrefix) SingleCollection(name, symbol, contractURI, tokenURIPrefix, address(this)) {}\n\n    /// @notice The function for token minting. It creates a new token. Can be called only by the contract owner.\n    ///         Must contain the signature of the format: `sha3(tokenContract.address.toLowerCase() + tokenId)`.\n    ///         Where `tokenContract.address` is the address of the contract and tokenId is the id in uint256 hex format.\n    ///         0 as uint256 must look like this: `0000000000000000000000000000000000000000000000000000000000000000`.\n    ///         The message **must not contain** the standard prefix.\n    /// @param tokenId - The id of a new token.\n    /// @param _fees - An array of the secondary fees for this token.\n    /// @param tokenURI - The suffix with `tokenURIPrefix` usually complements ipfs link to metadata object.\n    ///        The URI must link to JSON object with various fields: `name, description, image, external_url, attributes`.\n    ///        Can also contain another various fields.\n    function mint(uint256 tokenId, Fee[] memory _fees, string memory tokenURI) onlyOwner public {\n        _mint(msg.sender, tokenId, _fees);\n        _setTokenURI(tokenId, tokenURI);\n        if (tokenId \u003e maxTokenId)\n            maxTokenId = tokenId;\n    }\n}\n"},"TransferProxy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC1155.sol\";\nimport \"./IERC20.sol\";\nimport \"./DIERC20.sol\";\nimport \"./IBEP20.sol\";\n\n\n/// @notice ERC721 and ERC1155 transfer proxy.\ncontract TransferProxy is OwnableOperatorRole {\n\n    /// @notice Calls safeTransferFrom for ERC721.\n    /// @notice Can be called only by operator.\n    function erc721safeTransferFrom(IERC721 token, address from, address to, uint256 tokenId) external onlyOperator {\n        token.safeTransferFrom(from, to, tokenId);\n    }\n\n    /// @notice Calls safeTransferFrom for ERC1155.\n    /// @notice Can be called only by operator.\n    function erc1155safeTransferFrom(IERC1155 token, address from, address to, uint256 id, uint256 value, bytes calldata data) external onlyOperator {\n        token.safeTransferFrom(from, to, id, value, data);\n    }\n}\n\n/// @notice Transfer proxy for ERC721 tokens whithout safe transfer support.\ncontract TransferProxyForDeprecated is OwnableOperatorRole {\n\n    /// @notice Calls transferFrom for ERC721.\n    /// @notice Can be called only by operator.\n    function erc721TransferFrom(IERC721 token, address from, address to, uint256 tokenId) external onlyOperator {\n        token.transferFrom(from, to, tokenId);\n    }\n}\n\n/// @notice ERC20 transfer proxy.\ncontract ERC20TransferProxy is OwnableOperatorRole {\n\n    /// @notice Calls transferFrom for ERC20 and fails on error.\n    /// @notice Can be called only by operator.\n    function erc20safeTransferFrom(IERC20 token, address from, address to, uint256 value) external onlyOperator {\n        require(token.transferFrom(from, to, value), \"failure while transferring\");\n    }\n}\n\ncontract ERC20TransferProxyForDeprecated is OwnableOperatorRole {\n    /// @notice Calls transferFrom for ERC20 and fails on error.\n    /// @notice Can be called only by operator.\n    function erc20TransferFrom(DIERC20 token, address from, address to, uint256 value) external onlyOperator {\n       token.transferFrom(from, to, value);\n    }\n}\n\ncontract BEP20TransferProxy is OwnableOperatorRole {\n    /// @notice Calls transferFrom for BEP20 and fails on error.\n    /// @notice Can be called only by operator.\n    function bep20TransferFrom(IBEP20 token, address from, address to, uint256 value) external onlyOperator {\n       token.transferFrom(from, to, value);\n    }\n}\n\n"}}